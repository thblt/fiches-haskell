<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="fr" xml:lang="fr">
<head>
<title>Haskell</title>
<!-- 2016-12-22 jeu. 02:19 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Thibault Polge" />
<link rel="stylesheet" href="_site/theme/theme.css" type="text/css" />
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Haskell</h1>
<div id="table-of-contents">
<h2>Table des matières</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-0-1">0.1. Introduction</a></li>
</ul>
</li>
<li><a href="#sec-1">1. L'environnement de développement</a>
<ul>
<li><a href="#sec-1-1">1.1. GHC</a>
<ul>
<li><a href="#sec-1-1-1">1.1.1. GHC</a></li>
</ul>
</li>
<li><a href="#sec-1-2">1.2. Debuggers</a></li>
<li><a href="#sec-1-3">1.3. Cabal</a></li>
<li><a href="#sec-1-4">1.4. Stack</a></li>
</ul>
</li>
<li><a href="#sec-2">2. Le langage</a>
<ul>
<li><a href="#_types">2.1. Les types: généralités</a>
<ul>
<li><a href="#_identifiers">2.1.1. Nommage des identifiants</a></li>
<li><a href="#_algebraic-types">2.1.2. Types produits, types sommes, types exponentielles</a></li>
<li><a href="#sec-2-1-3">2.1.3. Types élémentaires</a></li>
</ul>
</li>
<li><a href="#data">2.2. Définition de types</a>
<ul>
<li><a href="#sec-2-2-1">2.2.1. Produits</a></li>
<li><a href="#sec-2-2-2">2.2.2. Sommes</a></li>
<li><a href="#syntaxe-denregistrement">2.2.3. Syntaxe d'enregistrement</a></li>
<li><a href="#sec-2-2-4">2.2.4. Les types comme contextes</a></li>
<li><a href="#sec-2-2-5">2.2.5. Types récursifs</a></li>
</ul>
</li>
<li><a href="#sec-2-3">2.3. Synonymes de types</a>
<ul>
<li><a href="#section">2.3.1. <code>type</code></a></li>
<li><a href="#sec-2-3-2">2.3.2. <code>newtype</code></a></li>
</ul>
</li>
<li><a href="#typeclasses">2.4. Classes de type</a>
<ul>
<li><a href="#sec-2-4-1">2.4.1. Créer une classe de type</a></li>
<li><a href="#sec-2-4-2">2.4.2. Dériver une classe de type</a></li>
<li><a href="#sec-2-4-3">2.4.3. Dérivation automatique</a></li>
</ul>
</li>
<li><a href="#_kinds">2.5. Sortes</a></li>
<li><a href="#sec-2-6">2.6. Conditionnels</a>
<ul>
<li><a href="#if-then-else">2.6.1. <code>if</code></a></li>
<li><a href="#sec-2-6-2">2.6.2. <code>case</code></a></li>
</ul>
</li>
<li><a href="#_lazyness">2.7. Évaluation paresseuse</a></li>
<li><a href="#sec-2-8">2.8. Polymorphisme</a>
<ul>
<li><a href="#sec-2-8-1">2.8.1. Polymorphisme paramétrique</a></li>
<li><a href="#polymorphisme-ad-hoc">2.8.2. Polymorphisme <i>ad hoc</i></a></li>
</ul>
</li>
<li><a href="#sec-2-9">2.9. Modules</a>
<ul>
<li><a href="#crire-un-module">2.9.1. Écrire un module</a></li>
<li><a href="#import">2.9.2. Importation de modules</a></li>
<li><a href="#modules-et-instances">2.9.3. Modules et instances</a></li>
</ul>
</li>
<li><a href="#sec-2-10">2.10. Le prélude</a></li>
<li><a href="#literateHaskell">2.11. Programmation lettrée</a></li>
</ul>
</li>
<li><a href="#functions">3. Fonctions</a>
<ul>
<li><a href="#sec-3-1">3.1. Fonctions et variables</a>
<ul>
<li><a href="#sec-3-1-1">3.1.1. Signature de type</a></li>
<li><a href="#infix-and-prefix-functions">3.1.2. Fonctions préfixes et infixes</a></li>
</ul>
</li>
<li><a href="#sec-3-2">3.2. Définition de fonctions</a>
<ul>
<li><a href="#fonctions-locales">3.2.1. Fonctions locales</a></li>
<li><a href="#fixit-pr-c-dence-et-associativit">3.2.2. Fixité (précédence et associativité)</a></li>
</ul>
</li>
<li><a href="#sec-3-3">3.3. Paramètres, motifs et gardes</a>
<ul>
<li><a href="#passage-de-param-tres">3.3.1. Passage de paramètres</a></li>
<li><a href="#sec-3-3-2">3.3.2. Filtrage par motif et gardes</a></li>
<li><a href="#pattern-matching">3.3.3. Filtrage par motifs</a></li>
<li><a href="#guards">3.3.4. Gardes</a></li>
</ul>
</li>
<li><a href="#_partial-application">3.4. Application partielle et currying</a></li>
<li><a href="#sec-3-5">3.5. Lambdas</a></li>
</ul>
</li>
<li><a href="#sec-4">4. Idiomes</a>
<ul>
<li><a href="#sec-4-1">4.1. Composition</a></li>
<li><a href="#sec-4-2">4.2. Récursivité</a>
<ul>
<li><a href="#r-cursivit-en-queue">4.2.1. Récursivité en queue</a></li>
<li><a href="#folds">4.2.2. Folds</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-5">5. Données</a>
<ul>
<li><a href="#lists">5.1. Listes</a></li>
<li><a href="#Monoid">5.2. Monoïdes</a></li>
</ul>
</li>
<li><a href="#sec-6">6. Control</a>
<ul>
<li><a href="#Functor">6.1. Foncteurs</a></li>
<li><a href="#Applicative">6.2. Foncteurs applicatifs</a></li>
<li><a href="#Monad">6.3. Monades</a></li>
</ul>
</li>
<li><a href="#IO">7. Entrées et sorties</a>
<ul>
<li><a href="#sec-7-1">7.1. Fonctions d'entrée sortie de base</a>
<ul>
<li><a href="#sec-7-1-1">7.1.1. Fonctions d'entrée</a></li>
<li><a href="#fonctions-de-sortie">7.1.2. Fonctions de sortie</a></li>
<li><a href="#manipulation-de-fichiers-ou-de-r-pertoires">7.1.3. Manipulation de fichiers ou de répertoires</a></li>
</ul>
</li>
<li><a href="#sec-7-2">7.2. Gestion des erreurs</a>
<ul>
<li><a href="#les-types-et">7.2.1. Les types <code>Maybe</code> et <code>Either</code></a></li>
<li><a href="#exceptions">7.2.2. Exceptions</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-8">8. Contenu à organiser</a>
<ul>
<li><a href="#sec-8-1">8.1. TODOs</a></li>
<li><a href="#sec-8-2">8.2. Conventions</a></li>
<li><a href="#about">8.3. À propos de ce document</a>
<ul>
<li><a href="#sec-8-3-1">8.3.1. Auteur et mainteneur</a></li>
<li><a href="#sec-8-3-2">8.3.2. Outils</a></li>
<li><a href="#licence">8.3.3. Licence</a></li>
</ul>
</li>
<li><a href="#sec-8-4">8.4. Bibliographie</a></li>
</ul>
</div>
</div>

<div id="outline-container-sec-0-1" class="outline-3">
<h3 id="sec-0-1"><span class="section-number-3">0.1</span> Introduction</h3>
<div class="outline-text-3" id="text-0-1">
<p>
J’apprends Haskell, et comme <a href="#about">je</a> suis consciencieux, je fais des fiches.
</p>

<p>
Elles n’ont pas la prétention d’être un support d’apprentissage autonome, et présupposent une connaissance, même élémentaire, du langage. Elles ont vocation à présenter, de manière extrêmement synthétique, pour mémoire ou référence, l’essentiel de Haskell, et pas à se substituer à un apprentissage sérieux.
</p>

<p>
J’ai décidé de préparer ces fiches pour combler un manque dans la documentation sur Haskell. Les livres dont je dispose sur le langage sont soit trop superficiels, soit insuffisamment systématiques. Certains présentent une version superficelle d’Haskell, d’autres, les plus élaborés, souffrent au contraire du syndrome de l’enseignant-passionné-mais-pas-méthodique : ils ne cessent de s’interrompre et de proposer des apartés hors de propos qui mobilisent soudainement des notions qui ne seront explicitées que plusieurs chapitres plus loin.
</p>

<div class="info">
<p>
Ce qui précède est <a href="http://haskellbook.com/">de moins en moins vrai</a>.
</p>

</div>


<p>
Ces fiches tentent donc une présentation plus rigoureusement systématique, mais sans prétention pédagogique. L’ordre d’exposition y est aussi linéaire que possible, mais les renvois se font dans les deux sens : une fiche peut faire référence au contenu d’une fiche antérieure comme ultérieure.
</p>

<p>
Ce travail est à peine entamé. À terme, il devrait offrir un aperçu complet du langage, et de quelques une des extensions de GHC.
</p>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> L'environnement de développement</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> GHC</h3>
<div class="outline-text-3" id="text-1-1">
<p>
L'implémentation de Haskell la plus répandue est GHC, <i>The Glasgow
Haskell Compiler</i>. GHC fournit trois binaires: un compilateur (<code>ghc</code>),
un interpréteur (<code>runghc</code>) et un interpréteur ligne à ligne (REPL)
(<code>ghci</code>).
</p>
</div>
<div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1"><span class="section-number-4">1.1.1</span> GHC</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
GHC reconnaît les formats d'entrées suivants:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Extension</th>
<th scope="col" class="left">Format</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left"><code>.hs</code></td>
<td class="left">Source Haskell</td>
</tr>

<tr>
<td class="left"><code>.lhs</code></td>
<td class="left">Source <a href="#literateHaskell">Literate Haskell</a></td>
</tr>
</tbody>
</table>

<div class="info">
<p>
La liaison d'un exécutable avec ghc a tendance à être très
longue, d'une part parce que ld est en général assez lent, d'autre part
parce que ghc tend à lier plus de symboles qu'il n'est nécessaire.
Pour accélérer la liaison (uniquement lors du développement et pas pour
produire des binaires destinés à la distribution, évidemment), on peut
invoquer ghc avec le drapeau <code>-dynamic</code>.
</p>

</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> Debuggers</h3>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> Cabal</h3>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> Stack</h3>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Le langage</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-_types" class="outline-3">
<h3 id="_types"><a id="sec-2-1" name="sec-2-1"></a><span class="section-number-3">2.1</span> Les types: généralités</h3>
<div class="outline-text-3" id="text-_types">

<p>
Haskell connaît deux espèces essentielles de type: les types de <b>données</b> et les types de <b>fonctions</b>.  Cette section traite uniquement des premiers, les seconds <a href="#functions">ont leur propre section</a>.
</p>
</div>

<div id="outline-container-_identifiers" class="outline-4">
<h4 id="_identifiers"><a id="sec-2-1-1" name="sec-2-1-1"></a><span class="section-number-4">2.1.1</span> Nommage des identifiants</h4>
<div class="outline-text-4" id="text-_identifiers">


<p>
En Haskell, la casse du premier caractère d'un identifiant a une importance.  Un nom de type ou un constructeur de type commencent toujours par une majuscule, un nom de fonction ou de variable par une minuscule.
</p>
</div>
</div>

<div id="outline-container-_algebraic-types" class="outline-4">
<h4 id="_algebraic-types"><a id="sec-2-1-2" name="sec-2-1-2"></a><span class="section-number-4">2.1.2</span> Types produits, types sommes, types exponentielles</h4>
<div class="outline-text-4" id="text-_algebraic-types">


<p>
Si on comprend qu'un type est un <b>ensemble</b> (de valeurs possibles), on voit aisément pourquoi on parle de types produit ou somme:
</p>

<ul class="org-ul">
<li>Une <b>alternative</b> entre type (<code>data OuBien = Chaine String | Entier Int</code>) a pour cardinal la <b>somme</b> des cardinaux des types qui le constituent.
</li>

<li>Une <b>combinaison</b> de types (<code>data ChaineEtEntier = ChaineEtEntier String Int</code>) a pour cardinal le <b>produit</b> des cardinaux des types qui le constituent.
</li>

<li>Une <b>application</b> de types (<code>TypeA -&gt; TypeB</code>) a pour cardinal le cardinal du type du résultat élevé à la <b>puissance</b> du cardinal du type du paramètre.  Le cardinal de <code>a -&gt; b</code> est donc \(\#b^{\#a}\).
</li>
</ul>

<p>
(Le cardinal d'un type défini avec <code>data</code> est simplement une somme de produits.)
</p>
</div>
</div>

<div id="outline-container-sec-2-1-3" class="outline-4">
<h4 id="sec-2-1-3"><span class="section-number-4">2.1.3</span> Types élémentaires</h4>
<div class="outline-text-4" id="text-2-1-3">
<p>
Haskell fournit un grand nombre de types élémentaires, dont les plus
importants sont résumés dans ce tableau:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 1 :</span> Types numériques essentiels, d'après cite:OSullivan2008.</caption>

<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Type</th>
<th scope="col" class="left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left"><code>Double</code></td>
<td class="left">Virgule flottante, double précision</td>
</tr>

<tr>
<td class="left"><code>Float</code></td>
<td class="left">Virgule flottante, simple précision</td>
</tr>

<tr>
<td class="left"><code>Integer</code></td>
<td class="left">Entier signé en précision arbitraire</td>
</tr>

<tr>
<td class="left"><code>Int</code></td>
<td class="left">Entier signé à précision fixe, intervalle minimum $$[-2^{29} ; 2^{29}-1]$$</td>
</tr>

<tr>
<td class="left"><code>Int8</code> , <code>Int16</code>, <code>Int32</code>, <code>Int64</code></td>
<td class="left">Entier signé de \(n\) bits</td>
</tr>

<tr>
<td class="left"><code>Word8</code>,  <code>Word16</code>,  <code>Word32</code>,  <code>Word64</code></td>
<td class="left">Entier non signé de \(n\) bits</td>
</tr>

<tr>
<td class="left"><code>Rational, ~Ratio a</code></td>
<td class="left">Nombre rationnel de précision arbitraire</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-data" class="outline-3">
<h3 id="data"><a id="sec-2-2" name="sec-2-2"></a><span class="section-number-3">2.2</span> Définition de types</h3>
<div class="outline-text-3" id="text-data">
</div>
<div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1"><span class="section-number-4">2.2.1</span> Produits</h4>
<div class="outline-text-4" id="text-2-2-1">
<div class="org-src-container">

<pre class="src src-haskell">data Book = NewBook String [String] Int
--                  ^               ^__ Année de publication
--                  |      ^___________ Auteurs
--                  |__________________ Titre
</pre>
</div>

<p>
Cette ligne définit un type nommé <code>Book</code> qui fournit un unique constructeur <code>NewBook</code>.  Le constructeur <code>NewBook</code> se comporte comme une fonction qui prend trois paramètres et qrenvoie un <code>Book</code>: <code>NewBook :: String -&gt; [String] -&gt; Int -&gt; Book</code>.  Pour construire un nouveau <code>Book</code>, on écrit donc <code>book = NewBook "Critique of Pure Reason" ["Immanuel Kant"] 1781</code>.  Dans cette syntaxe, les arguments du constructeur sont positionnels et doivent être fournis dans l'ordre de la déclaration.
</p>

<div class="info">
<p>
Il est légal et très courant, quand un type ne fournit qu'un seul constructeur, de donner à ce constructeur le nom du type. On aurait alors <code>data Book = Book String [String] Int</code>. L'exemple précédent les distingue par souci de clarté, mais n'est pas vraiment idiomatique.
</p>

</div>
</div>
</div>

<div id="outline-container-sec-2-2-2" class="outline-4">
<h4 id="sec-2-2-2"><span class="section-number-4">2.2.2</span> Sommes</h4>
<div class="outline-text-4" id="text-2-2-2">
<p>
Un type somme présente une alternative en offrant plusieurs constructeurs.
</p>

<div class="org-src-container">

<pre class="src src-haskell">data Bool = True | False
data Maybe a = Nothing | Just a
</pre>
</div>

<div class="info">
<p>
Les types produits et sommes ne sont pas mutuellement exclusifs: <code>data Something = This String Int | That String Bool</code>.
</p>

</div>
</div>
</div>


<div id="outline-container-syntaxe-denregistrement" class="outline-4">
<h4 id="syntaxe-denregistrement"><a id="sec-2-2-3" name="sec-2-2-3"></a><span class="section-number-4">2.2.3</span> Syntaxe d'enregistrement</h4>
<div class="outline-text-4" id="text-syntaxe-denregistrement">

<p>
La syntaxe d'enregistrement permet de nommer les champs.
</p>

<div class="org-src-container">

<pre class="src src-haskell">data Book = Book {
  bookTitle :: String, -- bookTitle :: Book -&gt; String
  bookAuthors :: [String], -- bookAuthors :: Book -&gt; [String]
  bookYear :: Int -- bookYear :: Book -&gt; Int
  }
</pre>
</div>

<p>
Un type qui utilise cette syntaxe peut être instantié avec des arguments
positionnels ou des arguments nommés. Ces derniers peuvent être fournis
dans n'importe quel ordre:
</p>

<div class="org-src-container">

<pre class="src src-haskell">crp = Book "Critique de la Raison Pure" ["Immanuel Kant"] 1781
tlp = Book {
  bookYear = 1921,
  bookAuthors = ["Ludwig Wittgenstein"],
  bookTitle = "Tractatus Logico-Philosophicus"
  }
</pre>
</div>

<p>
Il définit automatiquement une fonction accesseur pour chacun de ses
champs. Le type <code>Book</code> ci-dessus fournit ainsi trois fonctions
<code>bookYear :: Book -&gt; Int</code>, <code>bookAuthors :: Book -&gt; [String]</code> et
<code>bookTitle :: Book -&gt; String</code>:
</p>

<div class="org-src-container">

<pre class="src src-haskell">ghci&gt;  bookYear tlp 1921
</pre>
</div>

<p>
Enfin, il permet de construire une nouvelle valeur à partir des champs
d'une valeur existante:
</p>

<div class="org-src-container">

<pre class="src src-haskell">rp = tlp {bookTitle = "Recherches philosophiques", bookYear=1953}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-4" class="outline-4">
<h4 id="sec-2-2-4"><span class="section-number-4">2.2.4</span> Les types comme contextes</h4>
<div class="outline-text-4" id="text-2-2-4">
<p>
@TODO (On peut considérer un type algébrique comme un contexte sémantique pour un type natif.)
</p>
</div>
</div>

<div id="outline-container-sec-2-2-5" class="outline-4">
<h4 id="sec-2-2-5"><span class="section-number-4">2.2.5</span> Types récursifs</h4>
<div class="outline-text-4" id="text-2-2-5">
<p>
Un type peut faire référence à lui-même. On peut construire un type
liste identique au type natif de la façon suivante:
</p>

<div class="org-src-container">

<pre class="src src-haskell">data List a = Empty | Cons a (List a) list = (Cons 1 (Cons 2 (Cons 3
Empty)))
</pre>
</div>

<p>
Un arbre binaire:
</p>

<div class="org-src-container">

<pre class="src src-haskell">data BTree a = Node a (BTree a) (BTree a) | Empty deriving Show
</pre>
</div>
<p>
h
</p>
</div>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> Synonymes de types</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Haskell permet de définir des synonymes pour des types existants. Les synonymes de type permettent d'augmenter la lisibilité du code ou de masquer des détails d'implémentation.  Contrairement aux types définis avec <a href="#data"><code>data</code></a>, les informations des synonymes ne sont pas conservées à la compilation.
</p>
</div>

<div id="outline-container-section" class="outline-4">
<h4 id="section"><a id="sec-2-3-1" name="sec-2-3-1"></a><span class="section-number-4">2.3.1</span> <code>type</code></h4>
<div class="outline-text-4" id="text-section">
<p>
<code>type</code> crée un synonyme d'un type existant. Le synonyme et le type
auquel ils renvoient sont interchangeables.
</p>

<div class="org-src-container">

<pre class="src src-haskell">type ObjectId = Int16
</pre>
</div>

<p>
Les synonymes créés avec <code>type</code> peuvent servir:
</p>
<ul class="org-ul">
<li>À clarifier le sens des champs dans les types personnalisés sans
accesseurs (<code>type ISBN = Int</code> pour un type <code>Book</code>, par
exemple):
</li>
</ul>

<div class="org-src-container">

<pre class="src src-haskell">type Authors = [String] type Title = String type ISBN = Int type Year
= Int data Book2 = Authors Title Year ISBN
</pre>
</div>

<ul class="org-ul">
<li>Comme notation abrégée pour des types complexes fréquemment utilisés.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-haskell">type Weird = (Int -&gt; String) -&gt; (Int -&gt; Int) -&gt; [Int] -&gt; [(Int,
String, Int)]
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-3-2" class="outline-4">
<h4 id="sec-2-3-2"><span class="section-number-4">2.3.2</span> <code>newtype</code></h4>
<div class="outline-text-4" id="text-2-3-2">
<p>
Le mot-clé <code>newtype</code> permet de dupliquer un type, et crée un type
distinct de l'original. Les synonymes créés avec <code>newtype</code> ne sont
pas substituables avec le type dont ils sont synonymes. De plus, il
n'appartiennent pas automatiquement aux
<a href="#typeclasses">types de classe</a> de ce dernier.
Leur syntaxe est très proche de celle de <code>data</code>:
</p>
<div class="org-src-container">

<pre class="src src-haskell">newtype MyType = MyType Int
</pre>
</div>
</div>
<ol class="org-ol"><li><a id="sec-2-3-2-1" name="sec-2-3-2-1"></a>Contrairement à <code>data</code>,<br  /><div class="outline-text-5" id="text-2-3-2-1">
<p>
<code>newtype</code>:
</p>
<ul class="org-ul">
<li>n'autorise qu'un seul constructeur et un seul champ.
</li>
<li>ne conserve pas les informations du type après la compilation. Dans
le programme compilé, <code>MyType</code> ci-dessus est traité comme un
simple <code>Int</code>:
</li>
</ul>
</div>
</li>
<li><a id="sec-2-3-2-2" name="sec-2-3-2-2"></a>Contrairement à <code>type</code>,<br  /><div class="outline-text-5" id="text-2-3-2-2">
<p>
<code>newtype</code> ne maintient pas la substituabilité du nouveau type et du
type dont il est un synonyme. <code>type</code> sert à faciliter la lecture,
<code>newtype</code> est plutôt utilisé pour masquer l'implémentation.
</p>
</div>
</li>
<li><a id="sec-2-3-2-3" name="sec-2-3-2-3"></a><code>newtype</code> est principalement utile pour:<br  /><div class="outline-text-5" id="text-2-3-2-3">
<ul class="org-ul">
<li>Masquer un type sous-jacent sans la perte de performances liée à
l'usage de <code>data</code>:
</li>
</ul>

<div class="org-src-container">

<pre class="src src-haskell">type ResourceHandle = ResourceHandle Int16
</pre>
</div>

<ul class="org-ul">
<li>Permet, sans perte de performances, de fournir des instances
différentes d'un unique <a href="#typeclasses">classe de type</a> pour un
type.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-haskell">-- Data.Monoid
-- Booléen selon la conjonction newtype All = All { getAll :: Bool }
deriving (Eq, Ord, Read, Show, Bounded)
instance Monoid All where mempty = All True All x =mappend= All y =
All (x &amp;&amp; y)
-- Booléen selon la disjonction newtype Any = Any { getAny :: Bool }
deriving (Eq, Ord, Read, Show, Bounded)
instance Monoid Any where mempty = Any False Any x =mappend= Any y =
Any (x || y)
</pre>
</div>
</div>
</li></ol>
</div>
</div>

<div id="outline-container-typeclasses" class="outline-3">
<h3 id="typeclasses"><a id="sec-2-4" name="sec-2-4"></a><span class="section-number-3">2.4</span> Classes de type</h3>
<div class="outline-text-3" id="text-typeclasses">

<p>
Les classes de type ne sont pas des classes au sens que ce terme possède
en POO. Elles sont plus proches de ce qu'on nomme des interfaces : elles
décrivent des fonctions pour lesquelles un type qui appartient à la
classe fournit une implémentation.
</p>
</div>
<div id="outline-container-sec-2-4-1" class="outline-4">
<h4 id="sec-2-4-1"><span class="section-number-4">2.4.1</span> Créer une classe de type</h4>
<div class="outline-text-4" id="text-2-4-1">
<div class="org-src-container">

<pre class="src src-haskell">class Parsable a where
  parse :: String -&gt; a
</pre>
</div>
<p>
Une implémentation par défaut peut être fournie.  La classe de type <code>Eq</code> par exemple est définie comme:
</p>
<div class="org-src-container">

<pre class="src src-haskell">class Eq a where
  (==), (/=) :: a -&gt; a -&gt; Bool
  x /= y     =  not (x == y)
  x == y     =  not (x /= y)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-4-2" class="outline-4">
<h4 id="sec-2-4-2"><span class="section-number-4">2.4.2</span> Dériver une classe de type</h4>
<div class="outline-text-4" id="text-2-4-2">
<div class="org-src-container">

<pre class="src src-haskell">data CanardLapin = { canard :: Bool, lapin :: Bool }
instance Show CanardLapin where
  show (CanardLapin True False) = "Seulement un canard"
  show (CanardLapin False True) = "Seulement un lapin"
  show _ = "Un canard lapin!"
</pre>
</div>
<div class="warn">
<p>
À certaines classes de type sont associées des lois (lois des <a href="#Functor">foncteurs</a>, des <a href="#Monad">monades</a>, <i>etc.</i>) que le compilateur ne peut pas nécessairement contrôler. Il est donc possible de construire des instances pathologiques de classes de type sans recevoir d'avertissement du compilateur.
Autrement dit, le système des classes de types est en partie formel, en partie contractuel. Il convient de vérifier les dimensions contractuelles dans la documentation de la classe de type.  Il est aussi possible, dans une certaine mesure, d'automatiser la vérification de conformité.
</p>

</div>
</div>
</div>
<div id="outline-container-sec-2-4-3" class="outline-4">
<h4 id="sec-2-4-3"><span class="section-number-4">2.4.3</span> Dérivation automatique</h4>
<div class="outline-text-4" id="text-2-4-3">
<p>
Les types crées avec <code>data</code> et <code>newtype</code> peuvent dériver automatiquement certaines classes avec le mot clé <code>deriving</code>:
#+begin<sub>example</sub> haskell
data Something = Something Integer Integer deriving (Show)
#+end<sub>example</sub> haskell
La dérivation automatique est implémentée au niveau du compilateur.
</p>
</div>
</div>
</div>
<div id="outline-container-_kinds" class="outline-3">
<h3 id="_kinds"><a id="sec-2-5" name="sec-2-5"></a><span class="section-number-3">2.5</span> Sortes</h3>
<div class="outline-text-3" id="text-_kinds">

<p>
Les Kinds sont aux types ce que les types sont aux valeurs. Autrement
dit, c'est le type d'un constructeur de type.
Un type ordinaire a @TODO
</p>
</div>
</div>

<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6"><span class="section-number-3">2.6</span> Conditionnels</h3>
<div class="outline-text-3" id="text-2-6">
<p>
Haskell connaît deux structures conditionnelles: les tests binaires avec
<code>if</code>, et les cas de <code>case</code>.
</p>
</div>

<div id="outline-container-if-then-else" class="outline-4">
<h4 id="if-then-else"><a id="sec-2-6-1" name="sec-2-6-1"></a><span class="section-number-4">2.6.1</span> <code>if</code></h4>
<div class="outline-text-4" id="text-if-then-else">

<p>
Une clause <code>if</code> est une <b>expression</b>, pas une structure de contrôle. La syntaxe est <code>if a then b else c</code>, où <code>a</code> est une expression de type <code>Bool</code>, <code>b</code> et <code>c</code> des expressions d'un type quelconque. Si <code>a</code> est vraie, l'expression vaut <code>b</code>, sinon <code>c</code>.
</p>

<p>
Comme c'est une expression, on peut affecter son résultat directement à une variable:
</p>

<div class="org-src-container">

<pre class="src src-haskell">a = if even x then "pair" else "impair"
</pre>
</div>

<p>
Que <code>if</code> soit une primitive du compilateur n'est justifié que par le gain de clarté qu'il apporte.  L'implémenter en Haskell directement est trivial:
</p>

<div class="org-src-container">

<pre class="src src-haskell">if' :: Bool -&gt; a -&gt; a
if' True a _ = a
if' _ _ b = b
</pre>
</div>
</div>
</div>


<div id="outline-container-sec-2-6-2" class="outline-4">
<h4 id="sec-2-6-2"><span class="section-number-4">2.6.2</span> <code>case</code></h4>
</div>
</div>

<div id="outline-container-_lazyness" class="outline-3">
<h3 id="_lazyness"><a id="sec-2-7" name="sec-2-7"></a><span class="section-number-3">2.7</span> Évaluation paresseuse</h3>
<div class="outline-text-3" id="text-_lazyness">

<div class="org-src-container">

<pre class="src src-haskell">let a = [1..] -- a est la liste de l'ensemble des entiers positifs
let b = map ((^^) 2) a
</pre>
</div>

<p>
L'évaluation paresseuse a un prix, qui est une plus grande consommation
de mémoire : au lieu d'évaluer <code>2 + 2</code>, Haskell stocke un
thunk, c'est à dire en gros un calcul différé. Mais sur les gros
traitements récursifs, l'accumulation de thunk peut entrainer
rapidement un débordement de mémoire. La commande <code>seq</code> force
l'évaluation et permet d'éviter un débordement de mémoire.
</p>

<div class="info">
<p>
<b>L'évaluation paresseuse obéit à des règles strictes.</b>
</p>

<p>
Il est possible de déterminer avec précision <i>si</i> une expression va être
évaluée, et si oui <i>quand</i>. C'est parce qu'il est garanti qu'une
expression dont le résultat n'est pas utilisé ne sera pas évaluée qu'on
peut, par exemple, programmer des opérateurs logiques court-circuitants
directement en Haskell, ou manipuler des suites infinies.
</p>

</div>
</div>
</div>

<div id="outline-container-sec-2-8" class="outline-3">
<h3 id="sec-2-8"><span class="section-number-3">2.8</span> Polymorphisme</h3>
<div class="outline-text-3" id="text-2-8">
</div><div id="outline-container-sec-2-8-1" class="outline-4">
<h4 id="sec-2-8-1"><span class="section-number-4">2.8.1</span> Polymorphisme paramétrique</h4>
<div class="outline-text-4" id="text-2-8-1">
<p>
N'importe quelle <a href="#functions">fonction</a> ou <a href="#data">type</a> peut accepter des paramètres d'un type non défini. Sa signature remplace dans ce cas le nom d'un type par un paramètre de type, <a href="#_identifiers">qui commence par une minuscule</a>.
</p>
</div>

<ol class="org-ol"><li><a id="sec-2-8-1-1" name="sec-2-8-1-1"></a>Types polymorphiques<br  /><div class="outline-text-5" id="text-2-8-1-1">
<p>
Le type <code>Maybe</code>, qui représente une valeur possible, est un exemple
de type polymorphique. Il a deux constructeurs : <code>Nothing</code> et
<code>Just a</code>. <code>Nothing</code> ne prend pas de paramètre, et représente
l'absence de valeur. <code>Just a</code> prend un paramètre du type quelconque
<code>a</code>.
</p>

<div class="org-src-container">

<pre class="src src-haskell">ghci&gt; :type Just 3 Just 3 :: Num a =&gt; Maybe a ghci&gt; :type Just "Une
chaîne" Just "Une chaîne" :: Maybe [Char] ghci&gt; :type Nothing Nothing
:: Maybe a
</pre>
</div>
</div>
</li>

<li><a id="fonctions-polymorphiques" name="fonctions-polymorphiques"></a><a id="sec-2-8-1-2" name="sec-2-8-1-2"></a>Fonctions polymorphiques<br  /><div class="outline-text-5" id="text-fonctions-polymorphiques">
<p>
Une fonction peut accepter, ou renvoyer, des types non-définis.
</p>
<div class="org-src-container">

<pre class="src src-haskell">third :: [a] -&gt; Maybe a
third (_:_:x:_) = Just x
third _ = Nothing
</pre>
</div>
<div class="info">
<p>
<b>«Théorèmes gratuits»</b>
</p>

<p>
Comme une fonction polymorphique n'a pas accès au type réel de son
paramètre, on peut déduire (au sens strict) ce qu'elle peut faire à sa
seule signature.
</p>

<p>
La fonction <code>head :: [a] -&gt; a</code> n'a pas accès au type <code>a</code>, et par
conséquent ne peut ni construire un nouvel <code>a</code>, ni modifier un des
<code>a</code> du tableau qu'elle reçoit: elle doit en renvoyer un tel quel.
On peut donc déduire que <code>head b `elem` b</code>.
</p>

<p>
La fonction <code>fst :: (a, b) -&gt; a</code> ne peut <i>rien</i> faire d'autre que
renvoyer le premier élément de la paire qui lui est passée, et ignorer
le second.
</p>

<p>
cite:Wadler1989 (pp. 33-35, 38-39 et <i>passim</i>) explicite le
soubassement logico-mathématique de ce principe et montre des
applications à des cas beaucoup plus complexes que ces quelque exemples.
</p>

</div>
</div>
</li></ol>
</div>

<div id="outline-container-polymorphisme-ad-hoc" class="outline-4">
<h4 id="polymorphisme-ad-hoc"><a id="sec-2-8-2" name="sec-2-8-2"></a><span class="section-number-4">2.8.2</span> Polymorphisme <i>ad hoc</i></h4>
<div class="outline-text-4" id="text-polymorphisme-ad-hoc">
</div>
</div>
</div>
<div id="outline-container-sec-2-9" class="outline-3">
<h3 id="sec-2-9"><span class="section-number-3">2.9</span> Modules</h3>
<div class="outline-text-3" id="text-2-9">
</div><div id="outline-container-écrire-un-module" class="outline-4">
<h4 id="écrire-un-module"><a id="sec-2-9-1" name="sec-2-9-1"></a><span class="section-number-4">2.9.1</span> Écrire un module</h4>
<div class="outline-text-4" id="text-écrire-un-module">
<p>
Un module a le même nom que le fichier .hs qui le contient, et
<a href="#_identifiers">ce nom commence par une majuscule</a>. La déclaration de
module a la syntaxe suivante:
</p>
<div class="org-src-container">

<pre class="src src-haskell">-- MyModule.hs module Mod ( x, y, z ) where -- code
</pre>
</div>
<p>
Cette déclaration exporte les identifiants x, y et z du code qui la
suit. On exporterait la totalité des noms en enlevant la parenthèse, et
aucun en la laissant vide.
</p>
<div class="info">
<p>
Ce n'est pas une erreur de syntaxe que de ne pas respecter la
règle nom du module = nom du fichier. Un tel module ne serait simplement
pas importable, puisque le compilateur ne saurait pas où le trouver.
</p>

</div>
<p>
TODO exporter un type mais pas ses constructeurs.
</p>
</div>
</div>
<div id="outline-container-import" class="outline-4">
<h4 id="import"><a id="sec-2-9-2" name="sec-2-9-2"></a><span class="section-number-4">2.9.2</span> Importation de modules</h4>
<div class="outline-text-4" id="text-import">

<div class="org-src-container">

<pre class="src src-haskell">-- Commande                       -- Importé
import Mod                        -- x, y, z, Mod.x, Mod.y, Mod.z
import Mod ()                     -- Uniquement les instances, voir ci-dessous.
import Mod (x,y)                  -- x, y, Mod.x, Mod.y
import qualified Mod              -- Mod.x, Mod.y, Mod.z
import qualified Mod (x,y)        -- Mod.x, Mod.y
import Mod hiding (x,y)           -- z, Mod.z
import qualified Mod hiding (x,y) -- Mod.z
import Mod as Foo                 -- x, y, z, Foo.x, Foo.y, Foo.z
import Mod as Foo (x,y)           -- x, y, Foo.x, Foo.y
import qualified Mod as Foo       -- Foo.x, Foo.y, Foo.z
import qualified Mod as Foo (x,y) -- Foo.x, Foo.y
</pre>
</div>

<p>
D'après cite:Hudak2000
</p>

<p>
Même sans importer aucun nom (c'est le cas de <code>import Mod ()</code>), tout <code>import</code> importe les instances de classes de types définies dans le module importé.
</p>
</div>
</div>

<div id="outline-container-modules-et-instances" class="outline-4">
<h4 id="modules-et-instances"><a id="sec-2-9-3" name="sec-2-9-3"></a><span class="section-number-4">2.9.3</span> Modules et instances</h4>
<div class="outline-text-4" id="text-modules-et-instances">
<p>
Les instances de classes de types définies dans un module sont toujours
exportées et importées, quels que soient les noms explicitement importés
ou exportés, et même s'il n'y en a aucun.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-2-10" class="outline-3">
<h3 id="sec-2-10"><span class="section-number-3">2.10</span> Le prélude</h3>
<div class="outline-text-3" id="text-2-10">
<p>
Le Prélude (<code>Prelude</code>) est la librairie fondamentale d'Haskell.
Contrairement aux autres modules, il est importé implicitement (cette
importation peut néanmoins être contrôlée avec une
<a href="#import">clause <code>import</code></a> explicite).
</p>

<p>
L'implémentation de référence est écrite en Haskell.
</p>

<p>
Il est particulièrement intéressant de noter que parmi les définitions
fournies par le Prélude, un certain nombre sont, dans la plupart des
langages procéduraux, définies au niveau du compilateur. Parmi
celles-ci, on trouve notamment les opérateurs booléens
court-circuitants, dont l'implémentation est rendue triviale par le
principe d'évaluation paresseuse.
</p>


<div class="org-src-container">

<pre class="src src-haskell">module Prelude (
    module PreludeList, module PreludeText, module PreludeIO,
    Bool(False, True),
    Maybe(Nothing, Just),
    Either(Left, Right),
    Ordering(LT, EQ, GT),
    Char, String, Int, Integer, Float, Double, Rational, IO,

    -- These built-in types are defined in the Prelude, but
    -- are denoted by built-in syntax, and cannot legally
    -- appear in an export list.
    -- List type: []((:), [])
    -- Tuple types: (,)((,)), (,,)((,,)), etc.
    -- Trivial type: ()(())
    -- Functions: (-&gt;)

    Eq((==), (/=)),
    Ord(compare, (&lt;), (&lt;=), (&gt;=), (&gt;), max, min),
    Enum(succ, pred, toEnum, fromEnum, enumFrom, enumFromThen,
	 enumFromTo, enumFromThenTo),
    Bounded(minBound, maxBound),
    Num((+), (-), (*), negate, abs, signum, fromInteger),
    Real(toRational),
    Integral(quot, rem, div, mod, quotRem, divMod, toInteger),
    Fractional((/), recip, fromRational),
    Floating(pi, exp, log, sqrt, (**), logBase, sin, cos, tan,
	     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh),
    RealFrac(properFraction, truncate, round, ceiling, floor),
    RealFloat(floatRadix, floatDigits, floatRange, decodeFloat,
	      encodeFloat, exponent, significand, scaleFloat, isNaN,
	      isInfinite, isDenormalized, isIEEE, isNegativeZero, atan2),
    Monad((&gt;&gt;=), (&gt;&gt;), return, fail),
    Functor(fmap),
    mapM, mapM_, sequence, sequence_, (=&lt;&lt;),
    maybe, either,
    (&amp;&amp;), (||), not, otherwise,
    subtract, even, odd, gcd, lcm, (^), (^^),
    fromIntegral, realToFrac,
    fst, snd, curry, uncurry, id, const, (.), flip, ($), until,
    asTypeOf, error, undefined,
    seq, ($!)
  ) where
</pre>
</div>
<p>
Noms exportés par le Prélude d'Haskell 2010
(cite:Haskell2010)
</p>
</div>
</div>

<div id="outline-container-literateHaskell" class="outline-3">
<h3 id="literateHaskell"><a id="sec-2-11" name="sec-2-11"></a><span class="section-number-3">2.11</span> Programmation lettrée</h3>
<div class="outline-text-3" id="text-literateHaskell">


<p>
Haskell fait partie des rares langages à gérer nativement la
programmation lettrée. Les fichiers sources ont l'extension <code>.lhs</code> (au
lieu de <code>.hs</code>) et les blocs de code peuvent être délimités de deux
façons
</p>

<ul class="org-ul">
<li>Soit par des <b>chevrons</b>, à la façon de Markdown.  Les lignes de code commencent par un <code>&gt;</code>. Chaque bloc de code doit être précédé d’au moins une ligne vide.
</li>
<li>Soit par des délimiteurs d'environnement La\(\TeX\):  Le code est entouré de <code>\begin{code}</code> et <code>\end{code}</code>.
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-functions" class="outline-2">
<h2 id="functions"><a id="sec-3" name="sec-3"></a><span class="section-number-2">3</span> Fonctions</h2>
<div class="outline-text-2" id="text-functions">
</div>

<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> Fonctions et variables</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Haskell n'a pas de notion de variable au sens qu'a ce terme en
programmation procédurale. Il est possible d'assigner une expression ou
une valeur à un nom, avec la syntaxe <code>nom = expression</code>, mais
<code>nom</code> est immuable, et est donc plus proche d'une constante (c'est
une variable au sens mathématique du terme).
</p>

<p>
En combinant ceci avec les principes de transparence référentielle,
<a href="#_lazyness">d'évaluation paresseuse</a> et
<a href="#_partial-application">d'application partielle</a>, on voit facilement
qu'il n'existe aucune différence stricte entre une fonction et une
ariable, donc qu'il n'existe pas de variables. Par exemple:
</p>

<div class="org-src-container">

<pre class="src src-haskell">a = 3 * 2 times3 x = 3 * x b = times3 2 c = 6
</pre>
</div>

<p>
Ici, <code>times3</code> est une fonction, <code>a</code>, <code>b</code> et <code>c</code> des
variables. Dans la mesure où la valeur d'aucune n'est évaluée tant
qu'elle n'est pas utilisée, la variable <code>a</code> a strictement la même
valeur que <code>b</code>, qui n'est pas 6, mais le thunk <code>3 * 2</code>.
</p>

<div class="warn">
<p>
Cette identité n'est vraie que des fonctions pures. Les fonctions impures, comme par exemple <code>getLine</code>, peuvent évidemment renvoyer un résultat différent à chaque invocation. Voir la section portant sur <a href="#IO">les entrées-sorties</a>.
</p>

</div>

<p>
La suite de cette fiche ne s'intéresse donc qu'aux fonctions, puisque
les «variables» n'en sont qu'un cas particulier.
</p>
</div>

<div id="outline-container-sec-3-1-1" class="outline-4">
<h4 id="sec-3-1-1"><span class="section-number-4">3.1.1</span> Signature de type</h4>
<div class="outline-text-4" id="text-3-1-1">
<p>
La signature a la forme <code>f :: TypeA -&gt; TypeRet</code>, ce qui signifie que
la fonction prend un paramètre de type <code>TypeA</code> et renvoie une valeur
de type <code>TypeRet</code>.
Une fonction définie avec plusieurs paramètres a pour signature
<code>f :: TypeA -&gt; TypeB -&gt; TypeC -&gt; TypeRet</code>. Cette syntaxe est
explicitée fiche \fsee{partial-application-and-currying}.
Les fonctions d'ordre supérieur utilisent les parenthèses pour indiquer
qu'elles prennent une autre fonction en paramètre. Par exemple, le type
<code>map :: (a -&gt; b) -&gt; [a] -&gt; [b]</code> se lit : <code>map</code> prend comme
premier paramètre une fonction quelconque <code>x :: a -&gt; b</code>.
Une variable ou une fonction sans paramètres a pour type
<code>nom :: Type</code>.
</p>
</div>
</div>

<div id="outline-container-infix-and-prefix-functions" class="outline-4">
<h4 id="infix-and-prefix-functions"><a id="sec-3-1-2" name="sec-3-1-2"></a><span class="section-number-4">3.1.2</span> Fonctions préfixes et infixes</h4>
<div class="outline-text-4" id="text-infix-and-prefix-functions">

<p>
Une fonction est dite préfixe si son nom est placé avant ses
arguments, et infixe si son nom est placé entre ses arguments.
<code>map</code> est une fonction préfixe, <code>+</code> est infixe. La distinction
est syntaxique, et se fait au niveau des caractères qui constituent le
nom de la fonction.
</p>
</div>

<ol class="org-ol"><li><a id="sec-3-1-2-1" name="sec-3-1-2-1"></a>Fonctions infixes<br  /><div class="outline-text-5" id="text-3-1-2-1">
<p>
Une fonction infixe a un nom composé uniquement de symboles non alphanumériques: <code>+</code>,
<code>*</code> ou <code>&gt;&gt;=</code> sont infixes.
On peut utiliser une fonction infixe comme préfixe en entourant son nom
de parenthèses : <code>(+) 1 1</code>.
</p>
</div>
</li>

<li><a id="sec-3-1-2-2" name="sec-3-1-2-2"></a>Fonctions préfixes<br  /><div class="outline-text-5" id="text-3-1-2-2">
<p>
Une fonction préfixe
a un nom composé de caractères alphanumériques. <code>map</code>, <code>elem</code>
ou <code>foldr</code> sont préfixes.
On peut utiliser une fonction préfixe comme infixe en entourant son nom
de \enconcept{backticks}: <code>1 `elem` [1..10]</code>.
</p>
</div>
</li></ol>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> Définition de fonctions</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Une fonction se définit de la façon suivante:
</p>
<div class="org-src-container">

<pre class="src src-haskell">add :: a -&gt; b -- Signature de type, généralement optionnel. add x = expr
x
</pre>
</div>

<p>
Une fonction infixe se définit en entourant son nom de parenthèses,
comme pour l'utiliser en préfixe:
</p>

<div class="org-src-container">

<pre class="src src-haskell">(+/) a b = a + b + a / b
</pre>
</div>
</div>

<div id="outline-container-fonctions-locales" class="outline-4">
<h4 id="fonctions-locales"><a id="sec-3-2-1" name="sec-3-2-1"></a><span class="section-number-4">3.2.1</span> Fonctions locales</h4>
<div class="outline-text-4" id="text-fonctions-locales">
<p>
On peut définir des fonctions dont la visibilité est limitée à une
fonction. C'est utile pour définir des constantes, ou fournir des
fonctions utilitaires qui n'ont pas besoin d'être disponibles au niveau
du module. Haskell propose deux syntaxes: <code>let</code>, qui place les
variables locales <i>avant</i> le code de la fonction, et <code>where</code>, qui les
positionne <i>après</i>.
</p>


<div class="org-src-container">

<pre class="src src-haskell">circLet :: Fractional a =&gt; a -&gt; a
circLet radius = let pi   = 3.14
		     diam = 2 * radius
		 in pi * diam
</pre>
</div>

<div class="org-src-container">

<pre class="src src-haskell">circWhere :: Fractional a =&gt; a -&gt; a
circWhere radius = pi * diam
    where pi   = 3.141592653589793
	  diam = 2 * radius
</pre>
</div>


<ul class="org-ul">
<li>Le choix de l'une ou de l'autre syntaxe est une question de lisibilité.
</li>
<li>On peut les imbriquer: une fonction locale peut à son tour définir des fonctions locales, etc.
</li>
<li>La visiblité des fonctions locales est limitée à la définition englobante.
</li>
</ul>
</div>
</div>

<div id="outline-container-fixité-précédence-et-associativité" class="outline-4">
<h4 id="fixité-précédence-et-associativité"><a id="sec-3-2-2" name="sec-3-2-2"></a><span class="section-number-4">3.2.2</span> Fixité (précédence et associativité)</h4>
<div class="outline-text-4" id="text-fixité-précédence-et-associativité">
<p>
\label{defining-fixity}
L'associativité et la précédence sont collectivement nommées «fixité».
La fixité d'une fonction infixe (et de n'importe quelle fonction préfixe
dans sa forme infixe, comme <code>`elem`</code>) est fixée par une déclaration
<code>infixl</code> (associatif à gauche), <code>infixr</code> (associatif à droite) ou
<code>infix</code> (non-associatif ), suivie de l'ordre de précédence compris
entre 0 et 9 et du nom de la fonction:
</p>
<div class="org-src-container">

<pre class="src src-haskell">(+/) :: Num a =&gt; a -&gt; a -&gt; a infixl 9 +/ (+/) a b = a + b + a / b
</pre>
</div>
<p>
Il est possible de définir la fixité d'une fonction locale, directement
dans la clause <code>let</code> ou <code>where</code> où elle est définie.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> Paramètres, motifs et gardes</h3>
<div class="outline-text-3" id="text-3-3">
</div><div id="outline-container-passage-de-paramètres" class="outline-4">
<h4 id="passage-de-paramètres"><a id="sec-3-3-1" name="sec-3-3-1"></a><span class="section-number-4">3.3.1</span> Passage de paramètres</h4>
<div class="outline-text-4" id="text-passage-de-paramètres">
<p>
@TODO
</p>
</div>

<ol class="org-ol"><li><a id="sec-3-3-1-1" name="sec-3-3-1-1"></a>Déconstruction de types composites.<br  /><div class="outline-text-5" id="text-3-3-1-1">
<p>
«Déconstruire» un argument d'une fonction permet d'obtenir directement
les arguments du constructeur. Par exemple, la fonction suivante
déconstruit un constructeur de paire (tuple de deux éléments) pour en
renvoyer le premier:
</p>

<div class="org-src-container">

<pre class="src src-haskell">toggle :: (a, b) -&gt; a toggle (x, y) = (y, x)
</pre>
</div>

<p>
Un paramètre non utilisé peut être remplacé par un <code>_</code>:
</p>
<div class="org-src-container">

<pre class="src src-haskell">duplFirst :: (a, b) -&gt; (a, a) duplFirst (x, \_) = (x, x)
</pre>
</div>

<p>
On n'a pas besoin du second membre de la paire: on la décompose donc en
évitant de nommer cet élément.
</p>

<p>
De la même façon, si le paramètre est un <code>Maybe</code>, on peut récupérer
directement sa valeur en déconstruisant <code>Just</code>:
</p>

<div class="org-src-container">

<pre class="src src-haskell">double :: Maybe Int -&gt; Int double (Just x) = x * 2
</pre>
</div>
</div>
</li>

<li><a id="as-patterns" name="as-patterns"></a><a id="sec-3-3-1-2" name="sec-3-3-1-2"></a>Motifs nommés.<br  /><div class="outline-text-5" id="text-as-patterns">

<p>
On peut avoir besoin de déconstruire un paramètre selon un motif en conservant le paramètre entier. Les motifs nommés permettent d'éviter des suites déconstruction-reconstruction redondantes.  La fonction <code>suffixes</code> (d'après cite:OSullivan2008, 103) renvoie tous les suffixes d'une liste. Elle peut s'écrire:
</p>

<div class="org-src-container">

<pre class="src src-haskell">suffixes :: [a] -&gt; [[a]] suffixes xs(/:xs') = xs : suffixes xs'
suffixes / = []
</pre>
</div>
</div>
</li></ol>
</div>

<div id="outline-container-sec-3-3-2" class="outline-4">
<h4 id="sec-3-3-2"><span class="section-number-4">3.3.2</span> Filtrage par motif et gardes</h4>
<div class="outline-text-4" id="text-3-3-2">
<p>
Le filtrage par motifs et l'emploi de gardes permettent de proposer
différentes implémentations d'une même fonction selon les paramètres qui
y sont passés, de façon similaire à l'emploi de cas en notation
mathématique :
</p>

<p>
$$
</p>

<p>
f(x) =
</p>
\begin{cases}
 f(x-1) + x & \text{si } x > 0 \\
 1          & \text{sinon}
\end{cases}

<p>
$$
</p>

<p>
Le filtrage par motifs permet de choisir une implémentation selon le
type et dans une certaine mesure la valeur des paramètres, les gardes
selon une expression arbitraire.
</p>

<div class="info">
<p>
Le filtrage par motif et les gardes permettent de définir plusieurs cas qui se recouvrent. Par exemple, une fonction peut fournir une implémentation pour n'importe quelle liste, et une autre pour n'importe quelle liste <i>non vide</i>. Haskell utilise toujours la première implémentation qui s'applique aux paramètres, dans l'ordre de déclaration : il faut donc déclarer les moins générales en premier.
</p>

</div>
</div>
</div>

<div id="outline-container-pattern-matching" class="outline-4">
<h4 id="pattern-matching"><a id="sec-3-3-3" name="sec-3-3-3"></a><span class="section-number-4">3.3.3</span> Filtrage par motifs</h4>
<div class="outline-text-4" id="text-pattern-matching">

<p>
Le filtrage par motifs permet de filtrer selon un constructeur ou selon
une valeur arbitraire.
</p>
</div>

<ol class="org-ol"><li><a id="sec-3-3-3-1" name="sec-3-3-3-1"></a>Par constructeur.<br  /><div class="outline-text-5" id="text-3-3-3-1">
<p>
Le filtrage par constructeurs permet de sélectionner quel constructeur
d'un <a href="#_algebraic-types">type algébrique</a> correspond à quelle
implémentation.
</p>

<div class="org-src-container">

<pre class="src src-haskell">maybeIntToStr :: Maybe Int -&gt; String maybeIntToStr (Just a) = show a
maybeIntToStr Nothing = "NaN"
</pre>
</div>

<div class="org-src-container">

<pre class="src src-haskell">mySum :: (Num a) =&gt; [a] -&gt; a mySum (x:xs) = x + mySum xs mySum [] = 0
</pre>
</div>
</div>
</li>

<li><a id="sec-3-3-3-2" name="sec-3-3-3-2"></a>Par valeur littérale.<br  /><div class="outline-text-5" id="text-3-3-3-2">
<p>
Le filtrage par valeur littérale est le plus simple. Il choisit une
implémentation si un paramètre a une valeur déterminée.
</p>

<div class="org-src-container">

<pre class="src src-haskell">compte :: String -&gt; String -&gt; Int -&gt; String
compte singulier pluriel 0 = "Aucun(e) " ++ singulier
compte singulier pluriel 1 = "Un(e) " ++ singulier
compte singulier pluriel quantite = show quantite ++ " " ++ pluriel
</pre>
</div>

<div class="warn">
<p>
Une valeur littérale <i>doit</i> être littérale et ne peut pas, pour des raisons syntaxiques, être une variable.  Un nom de variable dans une définition de fonction est <b>toujours</b> un paramètre de la fonction, jamais un filtre par valeur.
</p>

</div>
</div>
</li>

<li><a id="paramètres-ignorés." name="paramètres-ignorés."></a><a id="sec-3-3-3-3" name="sec-3-3-3-3"></a>Paramètres ignorés.<br  /><div class="outline-text-5" id="text-paramètres-ignorés.">
<p>
Certaines implémentations d'une fonction peuvent ne pas faire usage de
tous les paramètres. On ignore un paramètre dans la définition avec le
symbole <code>_</code>:
La fonction <code>compte</code> ci-dessus pourrait s'écrire:
</p>
<div class="org-src-container">

<pre class="src src-haskell">compte :: String -&gt; String -&gt; Int -&gt; String
compte singulier _ 0 = "Aucun(e) " ++ singulier
compte singulier _ 1 = "Un(e) " ++ singulier
compte _ pluriel quantite = show quantite ++ " " ++ pluriel
</pre>
</div>
<p>
<code>_</code> n'est pas un nom de variable mais la mention explicite que le
paramètre ne sera pas utilisé.
</p>
</div>
</li></ol>
</div>
<div id="outline-container-guards" class="outline-4">
<h4 id="guards"><a id="sec-3-3-4" name="sec-3-3-4"></a><span class="section-number-4">3.3.4</span> Gardes</h4>
<div class="outline-text-4" id="text-guards">
<p>
Un garde est une expression de type <code>Bool</code>. Si l'expression s'évalue à <code>True</code>, l'implémentation qui suit est utilisée.
</p>

<p>
Leur syntaxe est:
</p>

<div class="org-src-container">

<pre class="src src-haskell">func args | garde = impl
</pre>
</div>

<p>
Par exemple, une fonction qui détermine si un nombre est pair, qui
s'implémenterait naïvement sous la forme
<code>isEven x = if x `mod` 2 == 0 then True else False</code> peut s'écrire
plus lisiblement:
</p>

<div class="org-src-container">

<pre class="src src-haskell">isEven x | x =mod= 2 == 0 = True isEven \_ = False
</pre>
</div>

<p>
La partie à gauche du garde peut être omise si elle est identique à
celle qui précède (c'est-à-dire si l'éventuel motif est le même):
</p>

<div class="org-src-container">

<pre class="src src-haskell">isEven x | x =mod= 2 == 0 = True | otherwise = False
</pre>
</div>

<div class="info">
<p>
<code>otherwise</code> est une constante définie dans le Prélude.
Sa valeur est simplement <code>True</code>.
</p>

</div>

<div class="warn">
<p>
<code>otherwise</code> est simplement définie comme <code>otherwise = True</code>. Son emploi est donc limité aux gardes.
</p>

</div>
</div>

<ol class="org-ol"><li><a id="sec-3-3-4-1" name="sec-3-3-4-1"></a>«Pattern guards»<br  /><div class="outline-text-5" id="text-3-3-4-1">
<p>
Haskell 2010 étend la syntaxe des gardes \todo{Cette section}
</p>
<div class="org-src-container">

<pre class="src src-haskell">gardes :: Int -&gt; String gardes a | odd a, a =mod= 5 == 0 = "Impair et/ou
multiple de 5" | even a = "Pair mais pas multiple de 5"
</pre>
</div>
<p>
\todo{}
</p>
</div>
</li></ol>
</div>
</div>

<div id="outline-container-_partial-application" class="outline-3">
<h3 id="_partial-application"><a id="sec-3-4" name="sec-3-4"></a><span class="section-number-3">3.4</span> Application partielle et currying</h3>
<div class="outline-text-3" id="text-_partial-application">

<p>
Une fonction, quel que soit le nombre de paramètres avec lequel elle a été déclarée, ne prend qu'un seul paramètre et renvoie une autre fonction. Le type de <code>+</code>, par exemple, est : <code>Num a =&gt; Num a -&gt; Num a -&gt; Num a</code>, ce qui signifie que <code>+</code> prend un premier paramètre d'un type de type <code>Num</code>
</p>
</div>
</div>

<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5"><span class="section-number-3">3.5</span> Lambdas</h3>
<div class="outline-text-3" id="text-3-5">
<div class="info">
<p>
Certaines fonctions du Prélude peuvent remplacer un lambda:
<code>const x</code> prend un paramètre et renvoie toujours x: c'est
l'équivalent de <code>\_ -&gt; x</code>.
</p>

</div>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Idiomes</h2>
<div class="outline-text-2" id="text-4">
<p>
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod
tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim
veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea
commodo consequat. Duis aute irure dolor in reprehenderit in voluptate
velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint
occaecat cupidatat non proident, sunt in culpa qui officia deserunt
mollit anim id est laborum."
</p>
</div>

<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> Composition</h3>
</div>
<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> Récursivité</h3>
<div class="outline-text-3" id="text-4-2">
</div><div id="outline-container-récursivité-en-queue" class="outline-4">
<h4 id="récursivité-en-queue"><a id="sec-4-2-1" name="sec-4-2-1"></a><span class="section-number-4">4.2.1</span> Récursivité en queue</h4>
<div class="outline-text-4" id="text-récursivité-en-queue">
</div>
</div>
<div id="outline-container-folds" class="outline-4">
<h4 id="folds"><a id="sec-4-2-2" name="sec-4-2-2"></a><span class="section-number-4">4.2.2</span> Folds</h4>
<div class="outline-text-4" id="text-folds">
</div>
</div>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Données</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-lists" class="outline-3">
<h3 id="lists"><a id="sec-5-1" name="sec-5-1"></a><span class="section-number-3">5.1</span> Listes</h3>
<div class="outline-text-3" id="text-lists">

<p>
Cette fiche résume quelques unes des fonctions essentielles applicables
à des listes.
</p>

<ul class="org-ul">
<li><code>head</code>, <code>tail</code>.
</li>
<li><code>take</code>, <code>takeWhile</code>, <code>drop</code>, <code>dropWhile</code>
</li>
</ul>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left"><code>(++)</code>, <code>(&lt;&gt;)</code></td>
<td class="left"><code>[a] -&gt; [a] -&gt; [a]</code></td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left"><code>head</code>, <code>last</code></td>
<td class="left"><code>[a] -&gt; a</code></td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left"><code>tail</code></td>
<td class="left"><code>[a] -&gt; [a]</code></td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left"><code>drop</code>, <code>take</code></td>
<td class="left"><code>Int -&gt; [a] -&gt; [a]</code></td>
<td class="left">Retient/retire \(n\) premiers éléments de la liste.</td>
</tr>

<tr>
<td class="left"><code>dropWhile</code>, <code>takeWhile</code></td>
<td class="left"><code>(a -&gt; Bool) -&gt; [a] -&gt; [a]</code></td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left"><code>map</code>, <code>fmap</code></td>
<td class="left"><code>(a -&gt; b) -&gt; [a] -&gt; [b]~</code></td>
<td class="left">Applique une fonction sur chaque élément</td>
</tr>

<tr>
<td class="left"><code>zip</code></td>
<td class="left"><code>[a] -&gt; [b] -&gt; [(a, b)]</code></td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left"><code>zip3</code></td>
<td class="left"><code>[a] -&gt; [b] -&gt; [c] -&gt; [(a, b, c)]</code></td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left"><code>zipWith</code></td>
<td class="left"><code>(a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]</code></td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left"><code>zipWith3</code></td>
<td class="left"><code>(a -&gt; b -&gt; c -&gt; d) -&gt; [a] -&gt; [b] -&gt; [c] -&gt; [d]</code></td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-Monoid" class="outline-3">
<h3 id="Monoid"><a id="sec-5-2" name="sec-5-2"></a><span class="section-number-3">5.2</span> Monoïdes</h3>
<div class="outline-text-3" id="text-Monoid">

<div class="org-src-container">

<pre class="src src-haskell">class Monoid a where mempty :: a -- \^ Identity of 'mappend' mappend ::
a -&gt; a -&gt; a -- \^ An associative operation mconcat :: [a] -&gt; a
#+BEGIN_EXAMPLE
	-- ^ Fold a list using the monoid.
	-- For most types, the default definition for 'mconcat' will be
	-- used, but the function is included in the class definition so
	-- that an optimized version can be provided for specific types.
	mconcat = foldr mappend mempty
#+END_EXAMPLE
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Control</h2>
<div class="outline-text-2" id="text-6">
<p>
Cette section décrit les classes de types définies dans le Prelude au
niveau du paquet <code>Control</code> et de ses sous-paquets. Il s'agit
principalement des <a href="#Functor">foncteurs</a>, des
<a href="#Applicative">foncteurs applicatifs</a>, des <a href="#Monad">monades</a>.
</p>

<div class="warn">
<p>
La hiérarchie des types a changé dans <code>base</code> 4.8.0.0, faisant de Monad une instance Applicative.
</p>

</div>
</div>

<div id="outline-container-Functor" class="outline-3">
<h3 id="Functor"><a id="sec-6-1" name="sec-6-1"></a><span class="section-number-3">6.1</span> Foncteurs</h3>
<div class="outline-text-3" id="text-Functor">

<p>
Il s'agit d'une <a href="#typeclasses">classe de type</a>, définie comme suit:
</p>

<div class="org-src-container">

<pre class="src src-haskell">class Functor f where fmap :: (a -&gt; b) -&gt; f a -&gt; f b
</pre>
</div>

<div class="law">
<ol class="org-ol">
<li><code>fmap id === id</code>. Mapper <code>id</code> sur un foncteur renvoie le
</li>
</ol>
<p>
même foncteur. Autrement dit, <code>fmap</code> ne peut pas introduire d'autres
modifications dans le foncteur que l'application de la fonction.
</p>
<ol class="org-ol">
<li><code>fmap (f . g)  ==  fmap f . fmap g</code>
</li>
</ol>

</div>

<p>
La métaphore la plus répandue pour décrire un foncteur consiste à le
comparer à une boîte qui contient une valeur. La métaphore est un peu
courte. Plus abstraitement, un foncteur est un type de
<a href="#_kinds">sorte</a> <code>* -&gt; *</code> qui permet l'application d'une fonction sur
les données du type encapsulée dans le foncteur.
Ainsi <code>-&gt;</code> (la définition de fonction) est un foncteur. Par exemple:
</p>

<div class="org-src-container">

<pre class="src src-haskell">a = (*) 2        -- Application partielle
b = fmap (*2) a  -- fmap
b 2              -- == 8
</pre>
</div>

<div class="info">
<p>
<code>fmap</code> est une généralisation de <code>map</code>, et peut donc toujours le remplacer.
</p>

</div>
</div>
</div>

<div id="outline-container-Applicative" class="outline-3">
<h3 id="Applicative"><a id="sec-6-2" name="sec-6-2"></a><span class="section-number-3">6.2</span> Foncteurs applicatifs</h3>
<div class="outline-text-3" id="text-Applicative">

<p>
Un foncteur applicatif est une structure intermédiaire entre un foncteur
et une monade.
</p>

<p>
Il s'agit d'une <a href="#typeclasses">classe de type</a>, définie comme suit:
</p>

<div class="org-src-container">

<pre class="src src-haskell">class Functor f =&gt; Applicative f where
  -- | Lift a value.
  pure :: a -&gt; f a

  -- | Sequential application.
  (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b

  -- | Sequence actions, discarding the value of the first argument.
  (*&gt;) :: f a -&gt; f b -&gt; f b
  a1 *&gt; a2 = (id &lt;$ a1) &lt;*&gt; a2
  -- This is essentially the same as liftA2 (const id), but if the
  -- Functor instance has an optimized (&lt;$), we want to use that instead.
  -- | Sequence actions, discarding the value of the second argument.
  (&lt;*) :: f a -&gt; f b -&gt; f a
  (&lt;*) = liftA2 const
</pre>
</div>
</div>
</div>

<div id="outline-container-Monad" class="outline-3">
<h3 id="Monad"><a id="sec-6-3" name="sec-6-3"></a><span class="section-number-3">6.3</span> Monades</h3>
<div class="outline-text-3" id="text-Monad">

<p>
Au plus simple, une monade est une classe de type définie comme suit:
</p>

<div class="org-src-container">

<pre class="src src-haskell">class Applicative m =&gt; Monad m where
  -- | Sequentially compose two actions, passing any value produced
  -- by the first as an argument tothe second.
  (&gt;&gt;=) :: forall a b. m a -&gt; (a -&gt; m b) -&gt; m b

  -- | Sequentially compose two actions, discarding any value produced
  -- by the first, like sequencing operators (such as the semicolon)
  -- in imperative languages.
  (&gt;&gt;)        :: forall a b. m a -&gt; m b -&gt; m b
  m &gt;&gt; k = m &gt;&gt;= \_ -&gt; k -- See Note [Recursive bindings for Applicative/Monad]
  {-# INLINE (&gt;&gt;) #-}
  -- | Inject a value into the monadic type.
  return      :: a -&gt; m a
  return      = pure
  -- | Fail with a message.  This operation is not part of the
  -- mathematical definition of a monad, but is invoked on pattern-match
  -- failure in a do expression.
  fail        :: String -&gt; m a
  fail s      = error s
</pre>
</div>

<p>
@TODO Déf propre, exemples, &gt;&gt;, &gt;&gt;=
</p>
</div>
</div>
</div>

<div id="outline-container-IO" class="outline-2">
<h2 id="IO"><a id="sec-7" name="sec-7"></a><span class="section-number-2">7</span> Entrées et sorties</h2>
<div class="outline-text-2" id="text-IO">

<p>
La gestion des entrées/sorties requiert un traitement spécifique dans un langage fonctionnel. Contrairement aux fonctions pures du langage, les fonctions d'E/S produisent des effets de bord, et violent le principe de transparence référentielle.
</p>

<p>
Le mécanisme d'E/S d'Haskell est implémenté sous la forme d'une <a href="#Monad">monade</a> nommée <code>IO</code>.
</p>

<p>
Contrairement à ce qui se fait en général dans les bouquins sur Haskell, il vaut mieux avoir vraiment compris les <a href="#_types">types</a>, les <a href="#typeclasses">classes de types</a> <i>et</i> les <a href="#Monad">monades</a> avant de se lancer dans l'exploration du mécanisme d'entrée/sortie.
</p>
</div>

<div id="outline-container-sec-7-1" class="outline-3">
<h3 id="sec-7-1"><span class="section-number-3">7.1</span> Fonctions d'entrée sortie de base</h3>
<div class="outline-text-3" id="text-7-1">
</div><div id="outline-container-sec-7-1-1" class="outline-4">
<h4 id="sec-7-1-1"><span class="section-number-4">7.1.1</span> Fonctions d'entrée</h4>
<div class="outline-text-4" id="text-7-1-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left"><code>Prelude</code></th>
<th scope="col" class="left"><code>h*</code></th>
<th scope="col" class="left">Fonctions</th>
<th scope="col" class="left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">✓</td>
<td class="left">✓</td>
<td class="left"><code>getChar :: IO Char</code></td>
<td class="left">Lit un caractère.</td>
</tr>

<tr>
<td class="left">✓</td>
<td class="left">✓</td>
<td class="left"><code>getLine :: IO String</code></td>
<td class="left">Lit une ligne.</td>
</tr>

<tr>
<td class="left">✓</td>
<td class="left">✓</td>
<td class="left"><code>getContents :: IO String</code></td>
<td class="left">Lit le contenu d'un fichier.</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-fonctions-de-sortie" class="outline-4">
<h4 id="fonctions-de-sortie"><a id="sec-7-1-2" name="sec-7-1-2"></a><span class="section-number-4">7.1.2</span> Fonctions de sortie</h4>
<div class="outline-text-4" id="text-fonctions-de-sortie">
</div>
</div>
<div id="outline-container-manipulation-de-fichiers-ou-de-répertoires" class="outline-4">
<h4 id="manipulation-de-fichiers-ou-de-répertoires"><a id="sec-7-1-3" name="sec-7-1-3"></a><span class="section-number-4">7.1.3</span> Manipulation de fichiers ou de répertoires</h4>
<div class="outline-text-4" id="text-manipulation-de-fichiers-ou-de-répertoires">
</div>
</div>
</div>
<div id="outline-container-sec-7-2" class="outline-3">
<h3 id="sec-7-2"><span class="section-number-3">7.2</span> Gestion des erreurs</h3>
<div class="outline-text-3" id="text-7-2">
</div><div id="outline-container-les-types-et" class="outline-4">
<h4 id="les-types-et"><a id="sec-7-2-1" name="sec-7-2-1"></a><span class="section-number-4">7.2.1</span> Les types <code>Maybe</code> et <code>Either</code></h4>
<div class="outline-text-4" id="text-les-types-et">
</div>
</div>
<div id="outline-container-exceptions" class="outline-4">
<h4 id="exceptions"><a id="sec-7-2-2" name="sec-7-2-2"></a><span class="section-number-4">7.2.2</span> Exceptions</h4>
<div class="outline-text-4" id="text-exceptions">
</div>
</div>
</div>
</div>

<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> Contenu à organiser</h2>
<div class="outline-text-2" id="text-8">
</div><div id="outline-container-sec-8-1" class="outline-3">
<h3 id="sec-8-1"><span class="section-number-3">8.1</span> TODOs</h3>
<div class="outline-text-3" id="text-8-1">
<p>
À intégrer, en vrac:
</p>
<ul class="org-ul">
<li>Idiome : Point-free style (RWH 120)
</li>
<li>Lexique : Liste de paires = association list (RWH 121)
</li>
<li>Extensions :
<ul class="org-ul">
<li>TypeSynonymInstances
</li>
<li>OverlappingInstances
</li>
</ul>
</li>
<li>monomorphisme (RWH 163, Haskell 98 4.5.5)
</li>
<li>IO
</li>
<li>Qu'est ce qu'une action (RWH 167, 184)
</li>
<li>Buffering (RWH 189)
</li>
<li>Data.ByteString, Data.ByteString.Lazy
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-8-2" class="outline-3">
<h3 id="sec-8-2"><span class="section-number-3">8.2</span> Conventions</h3>
<div class="outline-text-3" id="text-8-2">
<div class="info">
<p>
Une information, pour préciser un point ou renvoyer vers d'autres sources.
</p>

</div>

<div class="warn">
<p>
Un avertissement généralement important.
</p>

</div>

<div class="math">
<p>
Ces boîtes précisent un point concernant le soubassement mathématico-logique de Haskell.
</p>

</div>

<div class="law">
<p>
Les lois sont des propriétés attendues des instances de classes de type que le compilateur ne peut pas contrôler.
</p>

</div>
</div>
</div>

<div id="outline-container-about" class="outline-3">
<h3 id="about"><a id="sec-8-3" name="sec-8-3"></a><span class="section-number-3">8.3</span> À propos de ce document</h3>
<div class="outline-text-3" id="text-about">
</div>

<div id="outline-container-sec-8-3-1" class="outline-4">
<h4 id="sec-8-3-1"><span class="section-number-4">8.3.1</span> Auteur et mainteneur</h4>
<div class="outline-text-4" id="text-8-3-1">
<p>
<a href="https://thb.lt">Thibault Polge</a> (<a href="mailto:thibault@thb.lt">thibault@thb.lt</a>)
</p>
</div>
</div>

<div id="outline-container-sec-8-3-2" class="outline-4">
<h4 id="sec-8-3-2"><span class="section-number-4">8.3.2</span> Outils</h4>
<div class="outline-text-4" id="text-8-3-2">
<p>
Ce site est généré avec <a href="http://jaspervdj.be/hakyll/">Hakyll</a>, une librairie de génération de sites statiques écrite en Haskell.
</p>

<p>
Le thème est compilé avec <a href="http://sass-lang.com/">Sass</a> et utilise <a href="http://gridle.org/">Gridle</a>.
</p>

<p>
Le corps du texte est composé en <a href="https://www.google.com/fonts/specimen/Open+Sans">Open Sans</a>, les titres en <a href="https://www.google.com/fonts/specimen/Open+Sans+Condensed">Open Sans Condensed</a>.
</p>

<p>
Les icônes des différentes boîtes proviennent de différentes séries compilées sur IcoMoon
</p>
</div>
</div>

<div id="outline-container-licence" class="outline-4">
<h4 id="licence"><a id="sec-8-3-3" name="sec-8-3-3"></a><span class="section-number-4">8.3.3</span> Licence</h4>
<div class="outline-text-4" id="text-licence">

<p>
[[<img src="http://creativecommons.org/licenses/by-nc-sa/2.0/fr/][[[https://i.creativecommons.org/l/by-nc-sa/2.0/fr/80x15.png" alt="80x15.png" />]]]]
</p>


<p>
Pour l'instant, ce travail est mis à disposition sous la (relativement restrictive) <a href="https://creativecommons.org/licenses/by-nc-sa/2.0/fr/">Licence Creative Commons Attribution - Pas d'Utilisation Commerciale - Partage dans les Mêmes Conditions 2.0 France</a>.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-8-4" class="outline-3">
<h3 id="sec-8-4"><span class="section-number-3">8.4</span> Bibliographie</h3>
<div class="outline-text-3" id="text-8-4">
<p>
bibliography:bibliography.bib
bibliographystyle:unsrtnat
</p>
</div>
</div>
</div>
</div>
</body>
</html>
