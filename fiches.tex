\documentclass[a5paper,french]{article}

\usepackage[]{polyglossia}
\setdefaultlanguage{french}
\setotherlanguages{english}
\usepackage[margin=1cm, bmargin=2cm]{geometry}
\usepackage{framed}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{makeidx}
\usepackage[table]{xcolor}

% Fonts
\usepackage{fontspec}
\setmainfont{Palatino}
\setsansfont{Avenir Next Condensed}
\setmonofont{Inconsolata}

% Tables
\usepackage{adjustbox}
\usepackage{array}
\usepackage{tabularx}

\newcolumntype{R}[2]{%
    >{\adjustbox{angle=#1,lap=\width-(#2)}\bgroup}%
    l%
    <{\egroup}%
}
\newcommand*\rot{\multicolumn{1}{R{90}{1em}}}
\newcommand*\roth{\multicolumn{1}{R{45}{1em}}}

% === Minted ===
\usepackage{xcolor}
\usepackage[cache=false]{minted}
\usemintedstyle{manni}
\definecolor{bg}{rgb}{0.95,0.95,0.95}
\newminted{haskell}{bgcolor=bg,linenos}

% Bibliography
\usepackage[style=authoryear,maxnames=1]{biblatex}
\addbibresource{fiches.bib}

% Sectioning and TOC
\usepackage[explicit]{titlesec}
\usepackage{titletoc}

\titleformat{\section}[frame]
{\setlength\fboxrule{2.25pt}}
{}
{5mm}
{\Large\sffamily\filcenter\MakeUppercase{#1}}

\newcommand{\sectionbreak}{\clearpage}

\titleformat{\subsection}[hang]
{}
{\Roman{subsection}.}%Label
{.5em}%Sep
{\large\textbf #1}%before-code
[\hrule]%after-code

\titleformat{\subsubsection}[runin]
{}
{}%Label
{.5em}%Sep
{#1}%before-code
%[]%after-code

%Placeholders
\newcommand\code[1]{\texttt{#1}}
\newcommand{\cmd}[2][]{#2}
\newcommand{\concept}[2][]{#2}
\newcommand{\hsT}[2][]{\hs{#2}}
\newcommand{\hsTC}[2][]{\hs{#2}}
\newcommand{\oui}{X}
% Shorthands
\newcommand\hs[1]{\mintinline{haskell}{#1}}
\newenvironment{tableau}{\begin{table}[h]\footnotesize\sffamily}{\end{table}}

\begin{document}

\section{ Types de données}

\subsection{ Types élémentaires}

% \renewcommand\rot[1]{#1}
%\renewcommand\hsT[1]{#1}
%\renewcommand\hsTC[1]{#1}

Haskell fournit un grand nombre de types élémentaires, dont les plus importants sont résumés dans ce tableau:

\begin{tableau}
\rowcolors{2}{gray!25}{white}
\centering
\label{tbl:common_numeric_types}
\begin{tabularx}{\textwidth}{l X c c c c c c c}
Type                                                                & Description & \rot{\hsTC{Bits}} & \rot{\hsTC{Bounded}} & \rot{\hsTC{Floating}} & \rot{\hsTC{Fractional}} & \rot{\hsTC{Integral}} & \rot{\hsTC{Num}} & \rot{\hsTC{Real}} \\
\midrule
\hsT{Double}                                                              & Double-precision floating point            &      & \oui        & \oui         &            &          &     &      \\
\hsT{Float}                                                               & Single-precision floating-point (not recommended)            &      &         &          &            &          &     &      \\
\hsT{Int}                                                                 & Fixed-precision signed integer; minimum range $[-2^{29} ; 2^{29}-1]$            &      &         &          &            &          &     &      \\
\hsT{Int8}                                                               & 8-bit signed integer            &      &         &          &            &          &     &      \\
\hsT{Int16}                                                               & 16-bit signed integer                       &      &         &          &            &          &     &      \\
\hsT{Int32}                                                               & 32-bit signed integer                                  &      &         &          &            &          &     &      \\
\hsT{Int64}                                                             & 64-bit signed integer             &      &         &          &            &          &     &      \\
\hsT{Integer}                                                             & Arbitrary precision signed integer             &      &         &          &            &          &     &      \\
\hsT{Rational or~\hsTC{Ratio a}                                      &             &      &         &          &            &          &     &      \\
\hsT{Word}                                                                &             &      &         &          &            &          &     &      \\
\hsT{Word16}                                                              &             &      &         &          &            &          &     &      \\
\hsT{Word32}                                                              &             &      &         &          &            &          &     &      \\
\hsT{Word64}                                                              &             &      &         &          &            &          &     &      \\
\bottomrule
\end{tabularx}
\caption{Types numériques essentiels, d'après \cite{OSullivan2008}}
\end{tableau}

\subsection{ Création de types}
\subsubsection{ \hs{type} : Synonymes de types}
\subsubsection{ \hs{data} : Types utilisateurs}
\subsubsection{ \hs{newtype} : Synonymes "forts"}
\subsection{ Types algébriques du Prelude}
\subsubsection   { Maybe}
\subsubsection{ Either}
\section{ Nommage et contraintes}
\subsection{ La casse a une valeur syntaxique}
\section{ Évaluation paresseuse}

\begin{haskellcode}
let a = [1..] -- a est la liste de l'ensemble des entiers positifs
let b = map ((^^) 2) a
\end{haskellcode}

L'évaluation paresseuse a un prix, qui est une plus grande consommation de
mémoire : au lieu d'évaluer \hs{2 + 2}, Haskell stocke un \concept{thunk}, c'est
à dire en gros un calcul différé. Mais sur les gros traitements récursifs,
l'accumulation de \concept[thunk]{thunks} peut entrainer rapidement un
débordement de mémoire. La commande \cmd{seq} force l'évaluation et permet
d'éviter un débordement de mémoire.

\subsection{ seq}
\section{ Fonctions et variables}
\subsection{ Transparence référentielle : application de function = valeur}
\subsection{ Syntaxe des prototypes de fonctions}
        [Le prototype restreint les actions possibles de la fonction]
\subsection{ Fonctions préfixes et infixes}
\section{ Opérations sur des listes}
\section{ Entrées/sorties et fonctions impures}
\subsection{ type IO}
\section{ Polymorphisme}
\subsection{ Fonctions polymorphiques}
\subsection{ Inférence de type}
\section{ Classes de type (\concept{Typeclasses})}
\section{ Récursivité}
\subsection{ Récursivité en queue}
\subsection{ Folds}
\section{ Structures de contrôle}
\subsection{ \hs{if}}
\subsection{ \hs{case}}
\section{ Application partielle et currying}
\section{ Modules}
\subsection{ Écrire un module}
\subsection{ Importation des modules}
\section{ Composition}

\appendix

\section{Index}

\printindex

\end{document}
