Au plus simple, une monade est une classe de type définie comme suit:

\haskell
class Applicative m => Monad m where -- | Sequentially compose two
actions, passing any value produced -- by the first as an argument to
the second. (>>=) :: forall a b. m a -> (a -> m b) -> m b

#+BEGIN_EXAMPLE
    -- | Sequentially compose two actions, discarding any value produced
    -- by the first, like sequencing operators (such as the semicolon)
    -- in imperative languages.
    (>>)        :: forall a b. m a -> m b -> m b
    m >> k = m >>= \_ -> k -- See Note [Recursive bindings for Applicative/Monad]
    {-# INLINE (>>) #-}

    -- | Inject a value into the monadic type.
    return      :: a -> m a
    return      = pure

    -- | Fail with a message.  This operation is not part of the
    -- mathematical definition of a monad, but is invoked on pattern-match
    -- failure in a @do@ expression.
    fail        :: String -> m a
    fail s      = error s
#+END_EXAMPLE

\eof

\todo {Déf propre, exemples, >>, >>=} \todo{Return}
