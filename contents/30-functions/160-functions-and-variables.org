























Haskell n'a pas de notion de variable au sens qu'a ce terme en
programmation procédurale. Il est possible d'assigner une expression ou
une valeur à un nom, avec la syntaxe ~nom = expression~, mais
~nom~ est immuable, et est donc plus proche d'une constante (c'est
une variable au sens mathématique du terme).

En combinant ceci avec les principes de transparence référentielle,
[[#lazyness][d'évaluation paresseuse]] et
[[#partial-application][d'application partielle]], on voit facilement
qu'il n'existe aucune différence stricte entre une fonction et une
variable, donc qu'il n'existe pas de variables. Par exemple:

#begin_src haskell
a = 3 * 2 times3 x = 3 * x b = times3 2 c = 6 #end_src

Ici, ~times3~ est une fonction, ~a~, ~b~ et ~c~ des
variables. Dans la mesure où la valeur d'aucune n'est évaluée tant
qu'elle n'est pas utilisée, la variable ~a~ a strictement la même
valeur que ~b~, qui n'est pas 6, mais le thunk ~3 * 2~.

#begin_warn Cette identité n'est vraie que des fonctions pures. Les
fonctions impures, comme par exemple ~getLine~, peuvent évidemment
renvoyer un résultat différent à chaque invocation. Voir \fsee{io}.
#end_

La suite de cette fiche ne s'intéresse donc qu'aux fonctions, puisque
les «variables» n'en sont qu'un cas particulier.

* Signature de type
  :PROPERTIES:
  :CUSTOM_ID: signature-de-type
  :END:

\label{type-signatures}

La signature a la forme ~f :: TypeA -> TypeRet~, ce qui signifie que
la fonction prend un paramètre de type ~TypeA~ et renvoie une valeur
de type ~TypeRet~.

Une fonction définie avec plusieurs paramètres a pour signature
~f :: TypeA -> TypeB -> TypeC -> TypeRet~. Cette syntaxe est
explicitée fiche \fsee{partial-application-and-currying}.

Les fonctions d'ordre supérieur utilisent les parenthèses pour indiquer
qu'elles prennent une autre fonction en paramètre. Par exemple, le type
~map :: (a -> b) -> [a] -> [b]~ se lit : ~map~ prend comme
premier paramètre une fonction quelconque ~x :: a -> b~.

Une variable ou une fonction sans paramètres a pour type
~nom :: Type~.

* Fonctions préfixes et infixes
  :PROPERTIES:
  :CUSTOM_ID: fonctions-préfixes-et-infixes
  :END:

\label{infix-functions} \label{prefix-functions}

Une fonction est dite \concept{préfixe} si son nom est placé avant ses
arguments, et \concept{infixe} si son nom est placé entre ses arguments.
~map~ est une fonction préfixe, ~+~ est infixe. La distinction
est syntaxique, et se fait au niveau des caractères qui constituent le
nom de la fonction.

\subsubsection[Fonctions infixes]{Une fonction infixe}
a un nom composé uniquement de symboles non alphanumériques: ~+~,
~*~ ou ~>>=~ sont infixes.

On peut utiliser une fonction infixe comme préfixe en entourant son nom
de parenthèses : ~(+) 1 1~.

\subsubsection[Fonctions préfixes]{Une fonction préfixe}
a un nom composé de caractères alphanumériques. ~map~, ~elem~
ou ~foldr~ sont préfixes.

On peut utiliser une fonction préfixe comme infixe en entourant son nom
de \enconcept{backticks}: ~1 `elem` [1..10]~.
