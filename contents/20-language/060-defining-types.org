























La définition de nouveaux types se fait avec le mot-clé ~data~.

Un type peut combiner plusieurs autres types sous une forme proche de
celle d'un enregistrement ou d'un [[#tuple][tuple]] (comme un =struct=
en C) et/ou fournir une alternative entre plusieurs «sous-types» (comme
une =union=) qui ont chacun leur propre constructeur.

#begin_math Les types de Haskell sont algébriques, c'est-à-dire qu'ils
sont définis en enveloppant d'autres types dans des constructeurs, sous
la forme d'une somme et/ou d'un produit. La somme de plusieurs types est
une /alternative/ entre ces types, leur produit est leur combinaison
dans un enregistrement. #end_

* Combinaison de champs
  :PROPERTIES:
  :CUSTOM_ID: combinaison-de-champs
  :END:

\todo{phrase intro} Pour décrire un livre, on peut imaginer un type qui
réunirait une chaîne de caractères (le titre), un tableau de chaînes de
caractères (les noms des auteurs) et un nombre entier (l'année de
publication). Un tel type se déclare comme suit:

#begin_src haskell
data Book = NewBook String [String] Int #end_src

Cette ligne définit un type nommé ~Book~ qui fournit un unique
constructeur NewBook. NewBook se comporte comme une fonction qui prend
trois paramètres et renvoie un ~Book~:
~NewBook :: String -> [String] -> Int -> Book~.

Pour construire un nouveau ~Book~, on écrit donc
~book = NewBook "Critique of Pure Reason" ["Immanuel Kant"] 1781~.

Dans cette syntaxe, les arguments du constructeur sont positionnels et
doivent être fournis dans l'ordre de la déclaration.

#begin_info Il est légal et très courant, quand un type ne fournit qu'un
seul constructeur, de donner à ce constructeur le nom du type. On aurait
alors ~data Book = Book String [String] Int~. L'exemple précédent les
distingue par souci de clarté, mais n'est pas vraiment idiomatique.
#end_

* Alternative entre constructeurs
  :PROPERTIES:
  :CUSTOM_ID: algebraic-types
  :END:

Un type algébrique présente une alternative en offrant plusieurs
constructeurs.

#begin_src haskell
data Bool = True | False data Maybe a = Nothing | Just a #end_src

* Syntaxe d'enregistrement
  :PROPERTIES:
  :CUSTOM_ID: syntaxe-denregistrement
  :END:

La syntaxe d'enregistrement permet de nommer les champs.

#begin_src haskell
data Book = Book { bookTitle :: String -- bookTitle :: Book -> String
bookAuthors :: [String], -- bookAuthors :: Book -> [String] bookYear ::
Int, -- bookISBN :: Book -> Int } #end_src

Un type qui utilise cette syntaxe peut être instantié avec des arguments
positionnels ou des arguments nommés. Ces derniers peuvent être fournis
dans n'importe quel ordre:

#begin_src haskell
crp = Book "Critique de la Raison Pure" ["Immanuel Kant"] 1781 tlp =
Book { bookYear=1921, bookAuthors=["Ludwig Wittgenstein"],
bookTitle="Tractatus Logico-Philosophicus" } #end_src

Il définit automatiquement une fonction accesseur pour chacun de ses
champs. Le type ~Book~ ci-dessus fournit ainsi trois fonctions
~bookYear :: Book -> Int~, ~bookAuthors :: Book -> [String]~ et
~bookTitle :: Book -> String~:

#begin_src haskell
ghci>  bookYear tlp 1921 #end_src

Enfin, il permet de construire une nouvelle valeur à partir des champs
d'une valeur existante:

#begin_src haskell
rp = tlp {bookTitle = "Recherches philosophiques", bookYear=1953} #end_src

* Les types comme contextes
  :PROPERTIES:
  :CUSTOM_ID: les-types-comme-contextes
  :END:

* Cas particuliers
  :PROPERTIES:
  :CUSTOM_ID: cas-particuliers
  :END:

* Types énumérés
  :PROPERTIES:
  :CUSTOM_ID: types-énumérés
  :END:

* Types récursifs
  :PROPERTIES:
  :CUSTOM_ID: types-récursifs
  :END:

Un type peut faire référence à lui-même. On peut construire un type
liste identique au type natif de la façon suivante:

#begin_src haskell
data List a = Empty | Cons a (List a) list = (Cons 1 (Cons 2 (Cons 3
Empty))) #end_src

Un arbre binaire:

#begin_src haskell
data BTree a = Node a (BTree a) (BTree a) | Empty deriving Show #end_src
