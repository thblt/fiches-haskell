























Haskell permet de définir des synonymes pour des types existants. Les
synonymes de type permettent d'augmenter la lisibilité du code ou de
masquer des détails d'implémentation.

Contrairement aux types définis avec [[#kw:data][~data~]], les
informations des synonymes ne sont pas conservées à la compilation.

* ~type~
  :PROPERTIES:
  :CUSTOM_ID: section
  :END:

~type~ crée un synonyme d'un type existant. Le synonyme et le type
auquel ils renvoient sont interchangeables.

#begin_src haskell
type ObjectId = Int16 #end_src

Les synonymes créés avec ~type~ peuvent servir:

-  À clarifier le sens des champs dans les types personnalisés sans
   accesseurs (~type ISBN = Int~ pour un type ~Book~, par
   exemple):

   #begin_src haskell
   type Authors = [String] type Title = String type ISBN = Int type Year
   = Int data Book2 = Authors Title Year ISBN #end_src

-  Comme notation abrégée pour des types complexes fréquemment utilisés.

   #begin_src haskell
   type Weird = (Int -> String) -> (Int -> Int) -> [Int] -> [(Int,
   String, Int)] #end_src

* ~newtype~
  :PROPERTIES:
  :CUSTOM_ID: section-1
  :END:

Le mot-clé ~newtype~ permet de dupliquer un type, et crée un type
distinct de l'original. Les synonymes créés avec ~newtype~ ne sont
pas substituables avec le type dont ils sont synonymes. De plus, il
n'appartiennent pas automatiquement aux
[[#typeclasses][types de classe]] de ce dernier.

Leur syntaxe est très proche de celle de ~data~:

#begin_src haskell
newtype MyType = MyType Int #end_src

** Contrairement à ~data,~
   :PROPERTIES:
   :CUSTOM_ID: contrairement-à
   :END:

~newtype~:

-  n'autorise qu'un seul constructeur et un seul champ.

-  ne conserve pas les informations du type après la compilation. Dans
   le programme compilé, ~MyType~ ci-dessus est traité comme un
   simple ~Int~:

** Contrairement à ~type,~
   :PROPERTIES:
   :CUSTOM_ID: contrairement-à-1
   :END:

~newtype~ ne maintient pas la substituabilité du nouveau type et du
type dont il est un synonyme. ~type~ sert à faciliter la lecture,
~newtype~ est plutôt utilisé pour masquer l'implémentation.

** ~newtype~ est principalement utile pour:
   :PROPERTIES:
   :CUSTOM_ID: est-principalement-utile-pour
   :END:

-  Masquer un type sous-jacent sans la perte de performances liée à
   l'usage de ~data~:

   #begin_src haskell
   type ResourceHandle = ResourceHandle Int16 #end_src

-  Permet, sans perte de performances, de fournir des instances
   différentes d'un unique [[#typeclasses][classe de type]] pour un
   type.

   #begin_src haskell
   -- Data.Monoid

   -- Booléen selon la conjonction newtype All = All { getAll :: Bool }
   deriving (Eq, Ord, Read, Show, Bounded)

   instance Monoid All where mempty = All True All x =mappend= All y =
   All (x && y)

   -- Booléen selon la disjonction newtype Any = Any { getAny :: Bool }
   deriving (Eq, Ord, Read, Show, Bounded)

   instance Monoid Any where mempty = Any False Any x =mappend= Any y =
   Any (x || y) #end_src


