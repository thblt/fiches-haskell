























Haskell dispose d'un mécanisme d'importation de modules.

* Écrire un module
  :PROPERTIES:
  :CUSTOM_ID: écrire-un-module
  :END:

Un module a le même nom que le fichier .hs qui le contient, et
[[#identifiers][ce nom commence par une majuscule]]. La déclaration de
module a la syntaxe suivante:

#begin_src haskell
-- MyModule.hs module Mod ( x, y, z ) where -- code #end_src

Cette déclaration exporte les identifiants x, y et z du code qui la
suit. On exporterait la totalité des noms en enlevant la parenthèse, et
aucun en la laissant vide.

#begin_info Ce n'est pas une erreur de syntaxe que de ne pas respecter la
règle nom du module = nom du fichier. Un tel module ne serait simplement
pas importable, puisque le compilateur ne saurait pas où le trouver.
#end_

TODO exporter un type mais pas ses constructeurs.

* Importation de modules
  :PROPERTIES:
  :CUSTOM_ID: importation-de-modules
  :END:

\label{import}

#begin_src haskell
-- Commande Importé import Mod -- x, y, z, Mod.x, Mod.y, Mod.z import
Mod () -- Uniquement les instances, voir ci-dessous. import Mod (x,y) --
x, y, Mod.x, Mod.y import qualified Mod -- Mod.x, Mod.y, Mod.z import
qualified Mod (x,y) -- Mod.x, Mod.y import Mod hiding (x,y) -- z, Mod.z
import qualified Mod hiding (x,y) -- Mod.z import Mod as Foo -- x, y, z,
Foo.x, Foo.y, Foo.z import Mod as Foo (x,y) -- x, y, Foo.x, Foo.y import
qualified Mod as Foo -- Foo.x, Foo.y, Foo.z import qualified Mod as Foo
(x,y) -- Foo.x, Foo.y #end_src
\caption*{D'après \cite{Hudak2000}}

Même sans importer aucun nom (c'est le cas de ~import Mod ()~), tout
~import~ importe les instances de classes de types définies dans le
module importé.

* Modules et instances
  :PROPERTIES:
  :CUSTOM_ID: modules-et-instances
  :END:

Les instances de classes de types définies dans un module sont toujours
exportées et importées, quels que soient les noms explicitement importés
ou exportés, et même s'il n'y en a aucun.
