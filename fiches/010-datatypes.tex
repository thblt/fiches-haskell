\section{Types de données}
\label{sec:datatypes}

\subsection{ Types élémentaires}

Haskell fournit un grand nombre de types élémentaires, dont les plus importants sont résumés dans ce tableau:

\begin{tableau}
\label{tbl:common_numeric_types}
\begin{tabularx}{\textwidth}{lXc|c|c|c|c|c|c}
Type & Description & \rot{\hsTC{Bits}} & \rot{\hsTC{Bounded}} & \rot{\hsTC{Floating}} & \rot{\hsTC{Fractional}} & \rot{\hsTC{Integral}} & \rot{\hsTC{Num}} & \rot{\hsTC{Real}} \\
\midrule
\hsT{Double}                    &      Virgule flottante, double précision                                      &      & \coche & \coche &      &      &  \coche    &  \coche    \\
\hsT{Float}                     &      Virgule flottante, simple précision                                      &      & \coche     &  \coche    &      &      &  \coche    &  \coche    \\
\hsT{Int}                       &      Entier signé à précision fixe, intervalle minimum $[-2^{29} ; 2^{29}-1]$ &      &      &      &      &      &      &      \\
\hsT{Int8}                      &      Entier signé de 8 bits                                                   &      &      &      &      &      &      &      \\
\hsT{Int16}                     &      Entier signé de 16 bits                                                  &      &      &      &      &      &      &      \\
\hsT{Int32}                     &      Entier signé de 32 bits                                                  &      &      &      &      &      &      &      \\
\hsT{Int64}                     &      Entier signé de 64 bits                                                  &      &      &      &      &      &      &      \\
\hsT{Integer}                   &      Arbitrary precision signed integer                                       &      &      &      &      &      &      &      \\
\hsT{Rational} ou~\hsTC{Ratio a}&      Nombre rationnel de précision arbitraire                                 &      &      &      &      &      &      &      \\
\hsT{Word8}                     &      Entier non signé de 8 bits                                               &      &      &      &      &      &      &      \\
\hsT{Word16}                    &      Entier non signé de 16 bits                                              &      &      &      &      &      &      &      \\
\hsT{Word32}                    &      Entier non signé de 32 bits                                              &      &      &      &      &      &      &      \\
\hsT{Word64}                    &      Entier non signé de 64 bits                                              &      &      &      &      &      &      &      \\
\bottomrule
\end{tabularx}
\caption*{Types numériques essentiels, d'après \cite{OSullivan2008}}
\end{tableau}

\subsection{Types composites}

Haskell connaît deux types composites: les \textbf{tableaux} et les \textbf{n-uplets}.
Le type tableau se note \hs{[a]}, un n-uplet se note \hs{(a, b)}, \hs{(a, b, c)}, \emph{etc.}.
Un n-uplet a au moins deux éléments, à l'exception de \hs{()}, le n-uplet vide qui indique qu'une fonction ne renvoie pas de valeur.

Les tableaux sont typés: un tableau ne peut contenir des éléments que d'un type unique, pleinement paramétrisé. Par exemple, un tableau de type \hs{[(Integer, Char)]} (tableau de couples \hsT{Integer}, \hsT{Char}) ne peut pas contenir un autre type de n-uplet, par exemple \hs{(Integer, String)}.
