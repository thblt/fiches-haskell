\section{ Polymorphisme}
\label{polymorphism}

\subsection{Polymorphisme paramétrique}

N'importe quelle fonction \qsee{functions-and-variables} ou type \qsee{defining-types} peut accepter des paramètres d'un type non défini. Sa signature remplace dans ce cas le nom d'un type par un paramètre de type, qui commence par une minuscule \qsee{identifiers}.

\subsubsection{Types polymorphiques}

Le type \hsT{Maybe}, qui représente une valeur possible, est un exemple de type polymorphique. Il a deux constructeurs : \hs{Nothing} et \hs{Just a}. \hs{Nothing} ne prend pas de paramètre, et représente l'absence de valeur. \hs{Just a} prend un paramètre du type quelconque \hsTP{a}.

\begin{haskellcode}
ghci>:type Just 3
Just 3 :: Num a => Maybe a
ghci>:type Just "Une chaîne"
Just "Une chaîne" :: Maybe [Char]
ghci>:type Nothing
Nothing :: Maybe a
\end{haskellcode}

\subsubsection{Fonctions polymorphiques}

Une fonction peut accepter, ou renvoyer, des types non-définis.

\begin{haskellcode}
third :: [a] -> Maybe a
third (_:_:x:_) = Just x
third _ = Nothing
\end{haskellcode}

\begin{infobox}[«Théorèmes gratuits»]

Comme une fonction polymorphique n'a pas accès au type réel de son paramètre, on peut déduire (au sens strict) ce qu'elle peut faire à sa seule signature.

La fonction \hs{head :: [a] -> a} n'a pas accès au type \hsTP{a}, et par conséquent ne peut ni construire un nouvel \hsTP{a}, ni modifier un des \hsTP{a} du tableau qu'elle reçoit: elle doit en renvoyer un tel quel. On peut donc déduire que \hs{head b `elem` b}.

La fonction \hs{fst :: (a, b) -> a} ne peut \emph{rien} faire d'autre que renvoyer le premier élément de la paire qui lui est passée, et ignorer le second.

    \begin{refblock}
        \textcite{Wadler1989} explicite le soubassement logico-mathématique de ce principe et montre des applications à des cas beaucoup plus complexes que ces quelque exemples.
    \end{refblock}

\end{infobox}

\subsection{Polymorphisme \emph{ad hoc}}
