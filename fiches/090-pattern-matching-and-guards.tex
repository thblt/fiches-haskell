\section{Filtrage par motif et gardes}
\label{pattern-matching-and-guards}

Le filtrage par motifs et l'emploi de gardes permettent de proposer différentes implémentations d'une même fonction selon les paramètres qui y sont passés, de façon similaire à l'emploi de cas en notation mathématique :

\[
 f(x) =
  \begin{cases}
   f(x-1) + x & \text{si } x > 0 \\
   1          & \text{sinon}
  \end{cases}
\]

Le filtrage par motifs permet de choisir une implémentation selon le type et dans une certaine mesure la valeur des paramètres, les gardes selon une expression arbitraire.

\begin{infobox}
Le filtrage par motif et les gardes permettent de définir plusieurs cas qui se recouvrent. Par exemple, une fonction peut fournir une implémentation pour n'importe quelle liste, et une autre pour n'importe quelle liste \emph{non vide}. Haskell utilise toujours la première implémentation qui s'applique aux paramètres, dans l'ordre de déclaration : il faut donc déclarer les moins générales en premier.
\end{infobox}

\subsection{Filtrage par motifs}
\label{pattern-matching}

Le filtrage par motifs permet de filtrer selon un constructeur ou selon une valeur arbitraire.

\subsubsection{Par constructeur.} Le filtrage par constructeurs permet de sélectionner quel constructeur d'un type algébrique \qsee{algebraic-types} correspond à quelle implémentation.

\begin{haskellcode}
maybeIntToStr :: Maybe Int -> String
maybeIntToStr (Just a) = show a
maybeIntToStr Nothing  = "NaN"
\end{haskellcode}

\begin{haskellcode}
mySum :: (Num a) => [a] -> a
mySum (x:xs) = x + mySum xs
mySum []     = 0 -- [] est le constructeur de liste vide,
                 -- pas une valeur littérale !
\end{haskellcode}

\begin{warnbox}
L'implémentation de \hsFn{mySum} n'est pas optimale: il vaudrait mieux utiliser \hsFn{foldr} \qsee{foldr}.
\end{warnbox}

\subsubsection{Par valeur littérale.}

\subsubsection{Paramètres ignorés.}

Certaines implémentations d'une fonction peuvent ne pas faire usage de tous les paramètres. On ignore un paramètre dans la définition avec le symbole \hs{_}:

\begin{hslisting}
\begin{haskellcode}
timesX :: (Num a) => a -> [a] -> [a]
timesX a (x:xs) = a * x:timesX a xs
timesX _ []     = []
\end{haskellcode}
\caption {La dernière ligne définit le comportement de \hs{timesX} face à une liste vide. Dans ce cas, le multiplicateur n'est pas utilisé.}
\end{hslisting}

\subsection{Gardes}
\label{guards}

Un garde est une expression de type \hsT{Bool}. Si l'expression s'évalue à \hs{True}, l'implémentation qui suit est utilisée. Les gardes permettent d'éviter les constructions conditionnelles avec \hs{if} \qsee{if-then-else}. Leur syntaxe est:

\begin{haskellcode}
func args | garde = impl
\end{haskellcode}

Par exemple, une fonction qui détermine si un nombre est pair, qui s'implémenterait naïvement sous la forme \hs{isEven x = if x `mod` 2 == 0 then True else False} peut s'écrire plus lisiblement:

\begin{haskellcode}
isEven x | x `mod` 2 == 0 = True
isEven _ = False
\end{haskellcode}

ou encore:

\begin{haskellcode}
isEven x | x `mod` 2 == 0 = True
         | otherwise = False
\end{haskellcode}

\begin{infobox}
\hsFn{otherwise} est une constante définie dans le Prélude. Sa valeur est simplement \hs{True}.
\end{infobox}

\begin{compatbox}
La syntaxe \hs{f a | garde1, garde2, etc = impl} est une nouveauté de Haskell 2010.
\end{compatbox}
