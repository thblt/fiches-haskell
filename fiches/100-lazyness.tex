\section{Évaluation paresseuse}
\label{sec:lazyness}

\begin{haskellcode}
let a = [1..] -- a est la liste de l'ensemble des entiers positifs
let b = map ((^^) 2) a
\end{haskellcode}

L'évaluation paresseuse a un prix, qui est une plus grande consommation de
mémoire : au lieu d'évaluer \hs{2 + 2}, Haskell stocke un \enconcept{thunk}, c'est
à dire en gros un calcul différé. Mais sur les gros traitements récursifs,
l'accumulation de \concept[thunk]{thunks} peut entrainer rapidement un
débordement de mémoire. La commande \cmd{seq} force l'évaluation et permet
d'éviter un débordement de mémoire.

\begin{infobox}{L'évaluation paresseuse obéit à des règles strictes}%
Il est possible de déterminer avec précision \emph{si} une expression va être évaluée, et si oui \emph{quand}. C'est parce qu'il est garanti qu'une expression dont le résultat n'est pas utilisé ne sera pas évaluée qu'on peut, par exemple, programmer des opérateurs logiques court-circuitants directement en Haskell, ce qui est impossible dans la plupart des langages impératifs, où passer un paramètre à une fonction implique l'évaluation du paramètre.
\end{infobox}

\subsection[]{seq}

Lorem!
