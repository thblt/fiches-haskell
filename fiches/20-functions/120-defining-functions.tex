\section{Définition de fonctions}
\label{defining-functions}

Une fonction se définit de la façon suivante:

\begin{haskellcode}
add :: a -> b  -- Signature de type, généralement optionnel.
add x = expr x
\end{haskellcode}

Une fonction infixe se définit en entourant son nom de parenthèses, comme pour l'utiliser en préfixe:

\begin{haskellcode}
(+*) a b = a + b + a * b
\end{haskellcode}


\subsection{Paramètres}

\subsubsection{Déconstruction de types composites.}

«Déconstruire» un argument d'une fonction permet d'obtenir directement les arguments du constructeur. Par exemple, la fonction suivante déconstruit un constructeur de paire (tuple de deux éléments) pour en renvoyer le premier:

\begin{haskellcode}
toggle :: (a, b) -> a
toggle (x, y) = (y, x)
\end{haskellcode}

Un paramètre non utilisé peut être remplacé par un \hs{_}:

\begin{haskellcode}
duplFirst :: (a, b) -> (a, a)
duplFirst (x, _) = (x, x)
\end{haskellcode}

On n'a pas besoin du second membre de la paire: on la décompose donc en évitant de nommer cet élément.

De la même façon, si le paramètre est un \hsT{Maybe}, on peut récupérer directement sa valeur en déconstruisant \hsC{Just}:

\begin{haskellcode}
double :: Maybe Int -> Int
double (Just x) = x * 2
\end{haskellcode}

\subsubsection{Motifs nommés.}
\label{as-patterns}

On peut avoir besoin de déconstruire un paramètre selon un motif en conservant le paramètre entier. Les motifs nommés permettent d'éviter des suites déconstruction-reconstruction redondantes.

La fonction \hsFn{suffixes} \parencite[103]{OSullivan2008} renvoie tous les suffixes d'une liste. Elle peut s'écrire:

\begin{haskellcode}
suffixes :: [a] -> [[a]]
suffixes xs@(_:xs') = xs : suffixes xs'
suffixes _ = []
\end{haskellcode}

\subsection{Fonctions locales}

On peut définir des fonctions dont la visibilité est limitée à une fonction. C'est utile pour définir des constantes, ou fournir des fonctions utilitaires qui n'ont pas besoin d'être disponibles au niveau du module. Haskell propose deux syntaxes: \hs{let}, qui place les variables locales \emph{avant} le code de la fonction, et \hs{where},  qui les positionne \emph{après}.

\begin{halfwidth}
\begin{haskellcode}
circLet :: Fractional a => a -> a
circLet radius = let pi   = 3.14
                     diam = 2 * radius
                 in pi * diam
\end{haskellcode}
\end{halfwidth}\hfill%
\begin{halfwidth}
	\begin{haskellcode}
circWhere :: Fractional a => a -> a
circWhere radius = pi * diam
    where pi   = 3.141592653589793
          diam = 2 * radius
	\end{haskellcode}
\end{halfwidth}

\begin{itemize}
\item Le choix de l'une ou de l'autre syntaxe est une question de lisibilité.
\item On peut les imbriquer: une fonction définie dans une clause \hs{let}/\hs{where} peut à son tour définir des fonctions locales, etc.
\item La visiblité des fonctions locales est limitée à la définition englobante.
\end{itemize}

\subsection{Fixité (précédence et associativité)}
\label{defining-fixity}

L'associativité et la précédence sont collectivement nommées «fixité». La fixité d'une fonction infixe (et de n'importe quelle fonction préfixe dans sa forme infixe, comme \hs{`elem`}) est fixée par une déclaration \hs{infixl} (associatif à gauche), \hs{infixr} (associatif à droite) ou \hs{infix} (non-associatif
), suivie de l'ordre de précédence compris entre 0 et 9 et du nom de la fonction:

\begin{haskellcode}
(+*) :: Num a => a -> a -> a
infixl 9 +*
(+*) a b = a + b + a * b
\end{haskellcode}

Il est possible de définir la fixité d'une fonction locale, directement dans la clause \hs{let} ou \hs{where} où elle est définie.
